/******************************************************************************
* Copyright (c) 2004, 2017  Ericsson AB
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
*   Elemer Lelik - initial implementation
*   Endre Kulcsar
*   Eszter Susanszky
******************************************************************************/
//
//  File:               NTAF_ProviderConformance.ttcn
//  Description:        NTAF Conformance Test Suite 
//  Rev:                 
//  Prodnr:              
//  Updated:            2014-01-07
//  Contact:            http://ttcn.ericsson.se
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//  Module:  
//
//  Purpose:
//     
//
//  Module Parameters:
//      -
//
//  Module depends on:
//    -
//
///////////////////////////////////////////////////////////////////////////////

module NTAF_ProviderConformance
{
	modulepar 
	{
		float tsp_availabilityTimer := 10.0;
		float tsp_user_action_timer := 1200.0;

		boolean tsp_userAction := false;
		boolean tsp_ts002_preamble := true;

		boolean tsp_tc_preamble_postamble:=true;
		boolean tsp_tc_act_deact_separately:=true;
		boolean tsp_tc_act_deact_altogether:=true;

		boolean tsp_tc_discovering_harness_support:=true;
		boolean tsp_tc_open_session_separately:=true;
		boolean tsp_tc_open_session_altogether:=true;
		boolean tsp_tc_notify_action:=true;
		boolean tsp_tc_notify_close:=true;
		boolean tsp_tc_session_resource_availability:=true;
		boolean tsp_tc_invisible_and_automated:=true;
		boolean tsp_tc_perform_actions_cancelling:=true;
		boolean tsp_tc_visible_and_automated:=true;
		
		boolean tsp_tc_tool_resource:=true;
		boolean tsp_tc_get_attributes_connectors:=true;

		boolean tsp_tc_deactivate_wrong_actRef_separately:=true;
		boolean tsp_tc_activate_unsupportedMode:=true;
		boolean tsp_tc_activate_unsupportedHarness:=true;
		boolean tsp_tc_deactivate_wrong_actRef_altogether:=true;
		boolean tsp_tc_activate_already_activated:=true;
		boolean tsp_tc_deactivate_already_deactivated:=true;

		boolean tsp_tc_open_session_without_activation:=true;
		boolean tsp_tc_open_session_not_activated_mode:=true;
		boolean tsp_tc_open_session_unsupported_mode:=true;
		boolean tsp_tc_close_closed_session:=true;
		boolean tsp_tc_close_nonexisting_session:=true;
		boolean tsp_tc_close_closed_session_altogether:=true;
		boolean tsp_tc_open_unsupportedMode_session_altogether:=true;
		boolean tsp_tc_perform_nonexisting_action:=true;
		boolean tsp_tc_cancel_cancelled_action:=true;
		boolean tsp_tc_cancel_finished_action:=true;
		boolean tsp_tc_cancel_notStarted_action:=true;
		boolean tsp_tc_cancel_nonExisting_action:=true;
	}


import from IPL4asp_Types					all;
import from IPL4asp_PortType                          all;

import from http_ntaforum_org_2011_harness 		all;
import from http_ntaforum_org_2011_registry 		all;
import from http_ntaforum_org_2011_activation 		all;

import from http_jabber_org_protocol_pubsub 		all;
import from http_jabber_org_protocol_pubsub_errors 	all;
import from http_jabber_org_protocol_pubsub_event 	all;
import from http_jabber_org_protocol_pubsub_owner 	all;
import from http_etherx_jabber_org_streams            all;
import from http_jabber_org_protocol_disco_items 	all; 
import from http_jabber_org_protocol_disco_info 	all;

//import from jabber_server 					all;
import from jabber_client 					all;
import from jabber_x_data 					all;
import from jabber_iq_auth                       	all;


import from urn_ietf_params_xml_ns_xmpp_stanzas 	all;
import from urn_ietf_params_xml_ns_xmpp_bind          all;
import from urn_ietf_params_xml_ns_xmpp_sasl          all;
import from urn_ietf_params_xml_ns_xmpp_tls           all;


import from XSD                             	      all;

import from http_www_w3_org_XML_1998_namespace        all;

//import from  TCCOpenSecurity_Functions 	                all;
import from  TCCEncoding_Functions 	              	all; 

import from NTAF_templates              			all;
import from NTAF_common                        		all;




//*****************************************************************************************************
//LogIn, Presence
//*****************************************************************************************************
	
//*****************************************************************************************************
//Create, delete leaf node Requestor
//*****************************************************************************************************	
	

//****** Result ***************************************************************************************
	
	
	template CompositeClientIq  tr_CompIq_create_leaf_node_result:=
	{ 
		from_ := *, 
		id := "create_leaf_requestor", 
		lang := *, 
		to_ := *,
		type_ := result,
		elem := *, 
		error_ := * 
	}
	
	
	template CompositeClientIq  tr_CompIq_delete_leaf_node_result:=
	{ 
		from_ := *,
		id := "delete_leaf_node_req", 
		lang := *, 
		to_ := *, 
                type_ := result,
      		elem := *, 
		error_ := omit
	}
	
	
//*****************************************************************************************************
//Get leaf nodes
//*****************************************************************************************************	
	
	template jabber_client.Iq  t_Iq_get_nodes:=
	{
		from_:= omit,
		id:= "info_nodes",
		lang:= omit,
		to_:= "pubsub."&tsp_fqdn,
		type_:= get,
		elem:="<query xmlns='http://jabber.org/protocol/disco#items' node='ntaf.tools'/>",
		error_:=omit
	}
	
//****** Result ***************************************************************************************	

	template CompositeClientIq  tr_Iq_get_nodes_result:=
	{
		from_ := ?,
		id := "info_nodes",
		lang := omit,
		to_ := ?,
		type_ := result,
		elem :=
		{
			items_query :=
			{
				node := "ntaf.tools",
				sequence :=
				{
					item_list :=
					{
		           			{
							jid := ?,
							name := *,
							node := ?
		            			},
		            			*
		        		}
		    		}
		    	}
		},
	    	error_ := omit
	}


//*****************************************************************************************************
//Discover harness support
//*****************************************************************************************************	
	
	template jabber_client.Iq  ts_Iq_disco_info_provider_request(Node pl_node, integer pl_nodeNr):=
	{ 
		from_ := omit, 
		id := "disco_info_provider_" & int2str(pl_nodeNr), 
		lang := omit, 
		to_ := pl_node.nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"", 
		type_ := get,
		elem := "<query xmlns=\"http://jabber.org/protocol/disco#info\"/>", 
		error_ := omit 
	}
	
//****** Result ***************************************************************************************	
	
	template CompositeClientIq  tr_CompIq_disco_info_result_harness(Node pl_node, integer pl_nodeNr):=
	{
		from_ := pl_node.nodeId,
		id := "disco_info_provider_" & int2str(pl_nodeNr),
		lang := omit,
		to_ := tsp_username_requestor&"@"&tsp_fqdn&"/"&tsp_resource,//"titan0@e7d4c9efe72c63.ericsson.se/1",
		type_ := result,
		elem :=
		{
			info_query :=
			{
				node := *,
				sequence :=
				{
					identity_list :=
					{
						*
					},
					feature_list :=
					{
						*,
				    		{
				        		var_ := "http://ntaforum.org/2011/harness"
				    		},
				    		*
			       		},
					x := *
		   		}
			}
		},
	    	error_ := omit
	}
	
	
//*****************************************************************************************************
//Fetch tool registry
//*****************************************************************************************************		
	
	template jabber_client.Iq  t_Iq_fetch_tool_registry_request(RecordOfString pl_list_of_tool_nodes, integer pl_nodeNr):=
	{
		from_:=omit,
		id:= "q_fetch_tool_reg_" & int2str(pl_nodeNr),
		lang:=omit,
		to_:="pubsub."&tsp_fqdn,
		type_:=get,
		elem:=oct2char(enc_Pubsub(valueof(t_Pubsub_fetch_tool_registry_request(pl_list_of_tool_nodes, pl_nodeNr)))),
		error_:=omit
	}
	
	
	template http_jabber_org_protocol_pubsub.Pubsub t_Pubsub_fetch_tool_registry_request(RecordOfString pl_list_of_tool_nodes, integer pl_nodeNr) :=
	{
		choice :=
		{
			choice_list :=
			{	
				{
					items :=
					{
						max_items := omit,
						node := pl_list_of_tool_nodes[pl_nodeNr],
						subid := omit,
						item_list := { }
					}
	      		}
	    		}
	  	}
	}
	
//****** Result ***************************************************************************************
	
	template CompositeClientIq tr_fetch_tool_registry_result(RecordOfString pl_list_of_tool_nodes, integer pl_nodeNr) :=
	{
		from_ := "pubsub."&tsp_fqdn,   //e7d4c9efe72c63.ericsson.se",
		id := "q_fetch_tool_reg_" & int2str(pl_nodeNr),
		lang := omit,
		to_ := *,
		type_ := result,
		elem :=
		{
			pubsub_pubsub :=
			{
				choice :=
				{
					choice_list :=
					{
						{
							items :=
							{
								max_items := *,
								node := pl_list_of_tool_nodes[pl_nodeNr],
								subid := *,
								item_list :=
								{
									{
										id := *,
										sequence :=
								    		{
								    			elem := ?			
								   		}
									}
								}
							}
						},
						*
					}
				}
			}
		},
		error_ := omit
	}


//*****************************************************************************************************
//Get list of actions
//*****************************************************************************************************
	
	template jabber_client.Iq  ts_Iq_query_harness_provider_request(Node pl_node, Harness pl_harness, integer pl_nodeNr, integer pl_harnessNr):=
	{ 
		from_ := omit, 
		id := "query_harness_provider_" & int2str(pl_nodeNr) & int2str(pl_harnessNr),
		lang := omit, 
		to_ := pl_node.nodeId, 
		type_ := get,
		elem := oct2char(enc_Query_harness(valueof(t_query_harness(pl_harness.name)))),
		error_ := omit 
	}
	
//****** Result ***************************************************************************************
	
	template CompositeClientIq ts_Iq_query_harness_provider_request_result(Node pl_node, Harness pl_harness, integer pl_nodeNr, integer pl_harnessNr):=
	{
		from_ := pl_node.nodeId,
		id := "query_harness_provider_" & int2str(pl_nodeNr) & int2str(pl_harnessNr),
		lang := *,
		to_ := *,
		type_ := result,
		elem :=
		{
			harness_query_harness :=
			{
				harness := pl_harness.name, //intstead of "http://Example.org/ttcn/titan",
				lang := ?,
				label_ := ?,
				tooltip := ?,
				description := *,
				helpURI := *,
				supercedes := *,
				author := ?,
				actionDecl_list :=
				{
					* //at least one action is present
		    		},
				eventDecl_list := { *},
				subharness_list := {* }
			}
	    	},
		error_ := omit
	} 

	
//*****************************************************************************************************
//Activate, deactivate a tool
//*****************************************************************************************************
	
	template jabber_client.Iq ts_Iq_activate_always_on_tool_request(XSD.String pl_nodeId, XSD.String pl_toolId, XSD.String pl_harness, SessionMode pl_supportedMode, XSD.String pl_activationId):=
	{
		from_ := omit,
		id := "activate_provider_" & pl_activationId,
		lang := omit,
		to_ := pl_nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"",
		type_ := set_ ,
		elem := oct2char(enc_Activate(valueof(t_Activate_request(pl_toolId, pl_harness, pl_supportedMode)))),
		error_ := omit
	}
	
	template Activate t_Activate_request(XSD.String pl_toolId, XSD.String pl_harness, SessionMode pl_supportedMode):=
	{
		requestId := omit,
		toolId := pl_toolId, //"toaster@"&tsp_fqdn&"/1#always_on",
		result := pass_ ,
		message_ := omit,
		jid := omit,
		activationRef := omit,
		timestamp := omit,
		harness_list := 
		{
			{
				name := pl_harness, //"http://Example.org/ttcn/titan",
				supportedMode_list := {pl_supportedMode}
			}
		}
	}
	
	template jabber_client.Iq  ts_Iq_activate_unsupportedMode_request(XSD.String pl_nodeId, XSD.String pl_toolId, XSD.String pl_harness, XSD.String pl_activationId):=
	{
		from_ := omit,
		id := "activate_provider_" & pl_activationId,
		lang := omit,
		to_ := pl_nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"",
		type_ := set_ ,
		elem := oct2char(enc_Activate(valueof(t_Activate_request_unsupportedMode(pl_toolId, pl_harness)))),
		error_ := omit
	}
	
	template Activate t_Activate_request_unsupportedMode(XSD.String pl_toolId, XSD.String pl_harness):=
	{
		requestId := omit,
		toolId := pl_toolId, //"toaster@"&tsp_fqdn&"/1#always_on",
		result := pass_ ,
		message_ := omit,
		jid := omit,
		activationRef := omit,
		timestamp := omit,
		harness_list := 
		{
			{
				name := pl_harness, //"http://Example.org/ttcn/titan",
				supportedMode_list :=
				{
					invisible_and_automated,
					visible_and_automated,
					visible_and_interactive
				}
			}
		}
	}
	
	
	template jabber_client.Iq  ts_Iq_activate_unsupportedHarness_request(XSD.String pl_nodeId, XSD.String pl_toolId, XSD.String pl_activationId):=
	{
		from_ := omit,
		id := "activate_provider_" & pl_activationId,
		lang := omit,
		to_ := pl_nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"",
		type_ := set_ ,
		elem := oct2char(enc_Activate(valueof(t_Activate_request_unsupportedHarness(pl_toolId)))),
		error_ := omit
	}
	
	template Activate t_Activate_request_unsupportedHarness(XSD.String pl_toolId):=
	{
		requestId := omit,
		toolId := pl_toolId, //"toaster@"&tsp_fqdn&"/1#always_on",
		result := pass_ ,
		message_ := omit,
		jid := omit,
		activationRef := omit,
		timestamp := omit,
		harness_list := 
		{
			{
				name := f_generate_random_string(6), //"http://Example.org/ttcn/titan",
				supportedMode_list :=
				{
					invisible_and_automated,
					visible_and_automated,
					visible_and_interactive
				}
			}
		}
	}
	

	template jabber_client.Iq  ts_Iq_deactivate_always_on_tool_request(XSD.String v_actRef, XSD.String pl_nodeId, XSD.String pl_activationId):=
	{
		from_ := omit,
		id := "deactivate_provider_" & pl_activationId,
		lang := omit,
		to_ := pl_nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"",
		type_ := set_ ,
		elem := oct2char(enc_Deactivate(valueof(t_Deactivate(v_actRef)))),
		error_ := omit
	}
	
	
	template Deactivate t_Deactivate(universal charstring v_actRef):=
	{
		activationRef:= v_actRef
	}
	
	
//****** Result ***************************************************************************************
	
	template CompositeClientIq  tr_CompIq_request_Activate_request_pass(XSD.String pl_toolId, XSD.String pl_activationId):=
	{
		from_ := *,
		id := "activate_provider_" & pl_activationId,
		lang := *,
		to_ := tsp_username_requestor&"@"&tsp_fqdn&"/"&tsp_resource,
		type_ := result,
		elem :=
		{
			activation_activate :=
			{
				requestId  := *,
				toolId := pl_toolId,
				result := pass_,
				message_ := *,
				jid := *,
				activationRef := *,
				timestamp := *,
				harness_list := ?
			}
		},  
		error_ := omit
	}
	
	
	template CompositeClientMessage  tr_CompMessage_request_Activate_request_pass(XSD.String pl_nodeId, XSD.String pl_toolId, XSD.String pl_requestId, XSD.String pl_activationId):=
	{
		from_ := pl_nodeId,
		id := "activate_provider_" & pl_activationId,
		lang := "en",
		to_ := *,
		type_ := *,
		choice_list := {},
		elem_list :=
		{
			{
				activation_activate :=
				{
					requestId  := pl_requestId,
					toolId := pl_toolId,
					result := pass_,
					message_ := *,
					jid := *,
					activationRef := *,
					timestamp := *,
					harness_list := ?
				}
			}
		
		},
		error_ := omit
	} 
	
	
	template CompositeClientIq  tr_CompIq_request_Activate_request_pending(XSD.String pl_toolId, XSD.String pl_id):=
	{
		from_ := *,
		id := pl_id,
		lang := *,
		to_ := tsp_username_requestor&"@"&tsp_fqdn&"/"&tsp_resource,
		type_ := result,
		elem :=
		{
			activation_activate :=
			{
				requestId  := *,
				toolId := pl_toolId,
				result := pending,
				message_ := *,
				jid := *,
				activationRef := *,
				timestamp := *,
				harness_list := ?
			}
		},  
		error_ := omit
	}
	
	template CompositeClientIq  tr_CompIq_request_Activate_request_fail(XSD.String pl_toolId, XSD.String pl_activationId):=
	{
		from_ := *,
		id := "activate_provider_" & pl_activationId,
		lang := *,
		to_ := tsp_username_requestor&"@"&tsp_fqdn&"/"&tsp_resource,
		type_ := result,
		elem :=
		{
			activation_activate :=
			{
				requestId  := *,
				toolId := pl_toolId,
				result := fail_,
				message_ := *,
				jid := *,
				activationRef := *,
				timestamp := *,
				harness_list := ?
			}
		},  
		error_ := *
	}
	 

	template CompositeClientIq  tr_CompIq_deactivate_result(XSD.String pl_actRef, XSD.String pl_activationId):=
	{
		from_ := *,
		id := "deactivate_provider_" & pl_activationId,
		lang := *,
		to_ := *,
		type_ := result,
		elem :=
		{
			activation_deactivate :=
			{
				activationRef := pl_actRef
			}
		},
		error_ := omit
	}
	
	template CompositeClientIq  tr_CompIq_deactivate_result_fail(XSD.String pl_activationId):=
	{
		from_ := *,
		id := "deactivate_provider_" & pl_activationId,
		lang := *,
		to_ := *,
		type_ := result,
		elem := 
		{
			activation_deactivate :=
			{
				activationRef := ?
			}
		},
		error_ := ?
	}
	

//*****************************************************************************************************
//Open, close session(invisible and automated, visible and interactive, ...)
//*****************************************************************************************************	
	
	template jabber_client.Iq  ts_Iq_open_session_requestor(XSD.String v_actRef, XSD.String pl_nodeId, XSD.String pl_harness, SessionMode pl_mode, XSD.String pl_openId):=
	{
		from_ := omit,
		id := "open_session_" & pl_openId,
		lang := omit,
		to_ :=  pl_nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"",
		type_ := set_,
		elem := oct2char(enc_Open(valueof(t_open_session_requestor(pl_harness, pl_mode, v_actRef)))),
		error_ := omit
	}

	template Open t_open_session_requestor(XSD.String pl_harness, SessionMode pl_mode, XSD.String v_actRef):=
	{
		harness := pl_harness, //"http://Example.org/ttcn/titan",
		lang := omit,
		mode := pl_mode,
		reportUserActivity := omit,
		context := omit,
		parameter_list := { },
		xmlParameter_list := { },
		file_list := { },
		group_list := { },
		timestamp := omit,
		activationRef := v_actRef
	}

	
	template jabber_client.Iq  ts_Iq_close_session_requestor(XSD.String pl_nodeId, XSD.Name pl_session, XSD.String pl_openId):=
	{
		from_ := omit,
		id := "close_session_" & pl_openId,
		lang := omit,
		to_ := pl_nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"",
		type_ := set_ ,
		elem := oct2char(enc_Close(valueof(t_close_session_requestor(pl_session)))),
		error_ := omit
	}
	
	
	template Close t_close_session_requestor(XSD.Name pl_session):=
	{
		session := pl_session,
		timestamp := omit
	}
	
//****** Result ***************************************************************************************
		
	template CompositeClientIq tr_Iq_open_session_result_pass(XSD.String pl_openId):=
	{
		from_ := *,
		id := "open_session_" & pl_openId,
		lang := *,
		to_ := tsp_username_requestor&"@"&tsp_fqdn&"/"&tsp_resource, //"titan0@e7d4c9efe72c63.ericsson.se/1",
		type_ := result,
		elem :=
		{
			harness_response :=
			{
				lang := *,
				requestId := *,
				session := ?,
				result := pass_,
				message_ := *,
				duration := *,
				item_list := ?,
				xmlItem_list := ?,
				file_list := ?,
				group_list := ?,
				timestamp := *
			}
		},
		error_ := omit
	}
	
	template CompositeClientIq tr_Iq_open_session_result_pending(XSD.String pl_openId):=
	{
		from_ := *,
		id := "open_session_" & pl_openId,
		lang := *,
		to_ := tsp_username_requestor&"@"&tsp_fqdn&"/"&tsp_resource, //"titan0@e7d4c9efe72c63.ericsson.se/1",
		type_ := result,
		elem :=
		{
			harness_response :=
			{
				lang := *,
				requestId := *,
				session := ?,
				result := pending,
				message_ := *,
				duration := *,
				item_list := ?,
				xmlItem_list := ?,
				file_list := ?,
				group_list := ?,
				timestamp := *
			}
		},
		error_ := omit
	}
	
	template CompositeClientIq tr_Iq_open_session_result_fail(XSD.String pl_openId):=
	{
		from_ := *,
		id := "open_session_" & pl_openId,
		lang := *,
		to_ := tsp_username_requestor&"@"&tsp_fqdn&"/"&tsp_resource, //"titan0@e7d4c9efe72c63.ericsson.se/1",
		type_ := result,
		elem :=
		{
			harness_response :=
			{
				lang := *,
				requestId := *,
				session := ?,
				result := fail_,
				message_ := *,
				duration := *,
				item_list := ?,
				xmlItem_list := ?,
				file_list := ?,
				group_list := ?,
				timestamp := *
			}
		},
		error_ := *
	}

	template CompositeClientIq tr_Iq_close_session_result(XSD.Name pl_session, XSD.String pl_openId):=		
	{
		from_ := *,
		id := "close_session_" & pl_openId,
		lang := omit,
		to_ := *,
		type_ := result ,
		elem :=
		{
			harness_response :=
			{
				lang := omit,
				requestId := *,
				session := pl_session,
				result := pass_ ,
				message_ := omit,
				duration := omit,
				item_list := { },
				xmlItem_list := { },
				file_list := { },
				group_list := { },
				timestamp := omit
			}
		},
		error_ := omit
	}
	
	template CompositeClientIq tr_Iq_close_session_result_fail(XSD.Name pl_session, XSD.String pl_openId):=		
	{
		from_ := *,
		id := "close_session_" & pl_openId,
		lang := omit,
		to_ := *,
		type_ := result ,
		elem :=
		{
			harness_response :=
			{
				lang := omit,
				requestId := *,
				session := pl_session,
				result := fail_ ,
				message_ := omit,
				duration := omit,
				item_list := { },
				xmlItem_list := { },
				file_list := { },
				group_list := { },
				timestamp := omit
			}
		},
		error_ := *
	}


//*****************************************************************************************************
//Notify action
//*****************************************************************************************************	
	
	

//****** Result ***************************************************************************************

	template CompositeClientMessage tr_Message_notify_action(XSD.Name pl_sessionId) :=
	{
		from_ := *,
		id := *,
		lang := *,
		to_ := *,
		type_ := *,
		choice_list := { },
		elem_list := 
		{
			{
				harness_notify_action := 
				{
					lang := *,
					session := pl_sessionId,
					action_ := ?,
					started := ?,
					context := *,
					requestParameter_list := { },
					requestXmlParameter_list := { },
					requestFile_list := { },
					requestGroup_list := { },
					result := ?,
					message_ := *,
					duration := *,
					responseItem_list := ?,
					responseXmlItem_list := { },
					responseFile_list := { },
					responseGroup_list := { },
					timestamp := *
				}
			}
		},
		error_ := omit
	}

	
//*****************************************************************************************************
//Request action
//*****************************************************************************************************	
	
	template jabber_client.Iq  ts_Iq_perform_action(XSD.Name pl_session, Node pl_node, integer pl_harnessNr, integer pl_actionNr, XSD.String pl_actionId):=
	{ 
		from_ := omit, 
		id :=  "performing_action_" & pl_actionId,
		lang := omit,
		to_ := pl_node.nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"", 
		type_ := set_, 
		elem := oct2char(enc_Request(valueof(t_request(pl_session, pl_node, pl_harnessNr, pl_actionNr)))), 
		error_ := omit
	}	
	
	template Request t_request(XSD.Name pl_session, Node pl_node, integer pl_harnessNr, integer pl_actionNr) :=
	{
		session:= pl_session,
		context:=omit,
		parameter_list:= f_mapParameterDeclaration2RequestParameter(pl_node.harnesses[pl_harnessNr].action_list, pl_actionNr),//{},
		xmlParameter_list:={},
		file_list:={},
		group_list:={},
		timestamp:=omit,
		action_ :=
		{
			harness := pl_node.harnesses[pl_harnessNr].harness.name, //"http://Example.org/ttcn/titan",
			base := pl_node.harnesses[pl_harnessNr].action_list.actionDecl_list[pl_actionNr].name //"isToasting_Sync"
		}
	}
	
	
	
	template jabber_client.Iq  ts_Iq_perform_action_get_resources(XSD.Name pl_session, Node pl_node, integer pl_nodeNr):=
	{ 
		from_ := omit, 
		id :=  "get_resources_" & int2str(pl_nodeNr), 
		lang := omit,
		to_ := pl_node.nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"", 
		type_ := set_, 
		elem := oct2char(enc_Request(valueof(t_request_get_resources(pl_session)))), 
		error_ := omit
	}	
	
	template Request t_request_get_resources(XSD.Name pl_session) :=
	{
		session:= pl_session,
		context:=omit,
		parameter_list:={},
		xmlParameter_list:={},
		file_list:={},
		group_list:={},
		timestamp:=omit,
		action_ :=
		{
			harness := "http://ntaforum.org/2013/harness/resource/owner",
			base := "getResources"
		}
	}
	
	
	
	template jabber_client.Iq  ts_Iq_perform_action_request_user_input(XSD.Name pl_session, Node pl_node, XSD.String pl_resource, integer pl_nodeNr, integer pl_resourceNr):=
	{ 
		from_ := omit, 
		id :=  "request_user_input_" & int2str(pl_nodeNr) & int2str(pl_resourceNr),
		lang := omit,
		to_ := pl_node.nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"", 
		type_ := set_, 
		elem := oct2char(enc_Request(valueof(t_request_request_user_input(pl_session, pl_resource)))), 
		error_ := omit
	}	
	
	template Request t_request_request_user_input(XSD.Name pl_session, XSD.String pl_resource) :=
	{
		session:= pl_session,
		context:=omit,
		parameter_list:=
		{
			{
				name := "resource",
				base := "SELF"
			},
			{
				name := "message",
				base := "Please provide information for this resource."
			},
			{
				name := "uri",
				base := "http://ntaforum.org/inventory/?resource=" & pl_resource
			}
		},
		xmlParameter_list:={},
		file_list:={},
		group_list:={},
		timestamp:=omit,
		action_ :=
		{
			harness := "http://ntaforum.org/2013/harness/resource/inventory",
			base := "requestUserInput"
		}
	}
	
	
	
	template jabber_client.Iq  ts_Iq_perform_action_get_attributes(XSD.Name pl_session, Node pl_node, XSD.String pl_resource, integer pl_nodeNr, integer pl_resourceNr):=
	{ 
		from_ := omit, 
		id :=  "get_attributes_" & int2str(pl_nodeNr) & int2str(pl_resourceNr), 
		lang := omit,
		to_ := pl_node.nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"", 
		type_ := set_, 
		elem := oct2char(enc_Request(valueof(t_request_get_attributes(pl_session, pl_resource)))), 
		error_ := omit
	}	
	
	template Request t_request_get_attributes(XSD.Name pl_session, XSD.String pl_resource) :=
	{
		session:= pl_session,
		context:=omit,
		parameter_list:=
		{
			{
				name := "resource",
				base := pl_resource
			}
		},
		xmlParameter_list:={},
		file_list:={},
		group_list:={},
		timestamp:=omit,
		action_ :=
		{
			harness := "http://ntaforum.org/2013/harness/resource/inventory",
			base := "getAttributes"
		}
	}
	
	
	
	template jabber_client.Iq  ts_Iq_perform_action_get_connectors(XSD.Name pl_session, Node pl_node, XSD.String pl_resource, integer pl_nodeNr, integer pl_resourceNr):=
	{ 
		from_ := omit, 
		id :=  "get_connectors_" & int2str(pl_nodeNr) & int2str(pl_resourceNr), 
		lang := omit,
		to_ := pl_node.nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"", 
		type_ := set_, 
		elem := oct2char(enc_Request(valueof(t_request_get_connectors(pl_session, pl_resource)))), 
		error_ := omit
	}	
	
	template Request t_request_get_connectors(XSD.Name pl_session, XSD.String pl_resource) :=
	{
		session:= pl_session,
		context:=omit,
		parameter_list:=
		{
			{
				name := "resource",
				base := pl_resource
			}
		},
		xmlParameter_list:={},
		file_list:={},
		group_list:={},
		timestamp:=omit,
		action_ :=
		{
			harness := "http://ntaforum.org/2013/harness/resource/inventory",
			base := "getConnectors"
		}
	}
	
	
	
	template jabber_client.Iq  ts_Iq_perform_action_nonexisting(XSD.Name pl_session, Node pl_node, integer pl_harness, XSD.String pl_actionId):=
	{ 
		from_ := omit, 
		id :=  "nonexisting_action_" & pl_actionId,
		lang := omit,
		to_ := pl_node.nodeId, //"toaster@"&tsp_fqdn&"/"&tsp_resource&"", 
		type_ := set_,
		elem := oct2char(enc_Request(valueof(t_request_nonexisting(pl_session, pl_node, pl_harness)))), 
		error_ := omit
	}
	
	template Request t_request_nonexisting(XSD.Name pl_session, Node pl_node, integer pl_harness) :=
	{
		session:= pl_session,
		context:=omit,
		parameter_list:={},
		xmlParameter_list:={},
		file_list:={},
		group_list:={},
		timestamp:=omit,
		action_ :=
		{
			harness := pl_node.harnesses[pl_harness].harness.name, //"http://Example.org/ttcn/titan",
			base := f_generate_random_string(6)
		}
	}
	

//****** Result ***************************************************************************************

	template CompositeClientIq ts_Iq_perform_action_response(XSD.Name pl_session, http_ntaforum_org_2011_harness.Result pl_result, XSD.String pl_actionId):=
	{
		from_ := *,
		id := "performing_action_" & pl_actionId,
		lang := omit,
		to_ := *,
		type_ := result,
		elem :=
		{
			harness_response :=
			{
				lang := omit,
				requestId := *,
				session := pl_session,
				result := pl_result,
				message_ := omit,
				duration := omit,
				item_list :=
				{
					*
				},
				xmlItem_list := { },
				file_list := { },
				group_list := { },
				timestamp := omit
			}
		},
		error_ := omit
	}
	
	template CompositeClientIq ts_Iq_get_resources_response(XSD.Name pl_session, http_ntaforum_org_2011_harness.Result pl_result, integer pl_nodeNr):=
	{
		from_ := *,
		id := "get_resources_" & int2str(pl_nodeNr),
		lang := omit,
		to_ := *,
		type_ := result,
		elem :=
		{
			harness_response :=
			{
				lang := omit,
				requestId := *,
				session := pl_session,
				result := pl_result,
				message_ := omit,
				duration := omit,
				item_list :=
				{
					*
				},
				xmlItem_list := { },
				file_list := { },
				group_list := { },
				timestamp := omit
			}
		},
		error_ := omit
	}
	
	
	template CompositeClientIq ts_Iq_user_input_response(XSD.Name pl_session, http_ntaforum_org_2011_harness.Result pl_result, integer pl_nodeNr, integer pl_resourceNr):=
	{
		from_ := *,
		id := "request_user_input_" & int2str(pl_nodeNr) & int2str(pl_resourceNr),
		lang := omit,
		to_ := *,
		type_ := result,
		elem :=
		{
			harness_response :=
			{
				lang := omit,
				requestId := *,
				session := pl_session,
				result := pl_result,
				message_ := omit,
				duration := omit,
				item_list :=
				{
					*
				},
				xmlItem_list := { },
				file_list := { },
				group_list := { },
				timestamp := omit
			}
		},
		error_ := omit
	}
	
	template CompositeClientIq ts_Iq_get_attributes_response(XSD.Name pl_session, http_ntaforum_org_2011_harness.Result pl_result, integer pl_nodeNr, integer pl_resourceNr):=
	{
		from_ := *,
		id := "get_attributes_" & int2str(pl_nodeNr) & int2str(pl_resourceNr),
		lang := omit,
		to_ := *,
		type_ := result,
		elem :=
		{
			harness_response :=
			{
				lang := omit,
				requestId := *,
				session := pl_session,
				result := pl_result,
				message_ := omit,
				duration := omit,
				item_list :=
				{
					*
				},
				xmlItem_list := { },
				file_list := { },
				group_list := { },
				timestamp := omit
			}
		},
		error_ := omit
	}
	
	template CompositeClientIq ts_Iq_get_connectors_response(XSD.Name pl_session, http_ntaforum_org_2011_harness.Result pl_result, integer pl_nodeNr, integer pl_resourceNr):=
	{
		from_ := *,
		id := "get_connectors_" & int2str(pl_nodeNr) & int2str(pl_resourceNr),
		lang := omit,
		to_ := *,
		type_ := result,
		elem :=
		{
			harness_response :=
			{
				lang := omit,
				requestId := *,
				session := pl_session,
				result := pl_result,
				message_ := omit,
				duration := omit,
				item_list :=
				{
					*
				},
				xmlItem_list := { },
				file_list := { },
				group_list := { },
				timestamp := omit
			}
		},
		error_ := omit
	}
	
	template CompositeClientMessage ts_Message_perform_action_response_event(XSD.Name pl_session, Node pl_node, integer pl_harness, integer pl_actionNr):=
	{
		from_ := omit,
		id := *,
		lang := *,
		to_ := *,
		type_ := *,
		choice_list := {},
		elem_list :=
		{
			{
				harness_event :=
				{
					harness := pl_node.harnesses[pl_harness].harness.name,
					lang := *,
					name := ?,
					session := pl_session,
					timestamp := ?,
					item_list := {},
					xmlItem_list := {},
					file_list := {},
					group_list := {}
				}
			},
			*
		},
		error_ := omit
	}
	
	template CompositeClientMessage tr_Message_perform_action_response_pass(XSD.Name pl_session, Node pl_node, integer pl_harness, integer pl_actionNr, XSD.String pl_actionId):=
	{
		from_ := *,
		id := ?, // "performing_action_" & pl_actionId,
		lang := *,
		to_ := *,
		type_ := *,
		choice_list := {},
		elem_list :=
		{
			{
				harness_response :=
				{
					lang := *,
					requestId := "performing_action_" & pl_actionId,
					session := pl_session,
					result := pass_,
					message_ := *,
					duration := *,
					item_list := {*},
					xmlItem_list := {},
					file_list := {},
					group_list := {},
					timestamp := *
				}
			}
		},
		error_ := omit
	}

	
//*****************************************************************************************************
//Cancel
//*****************************************************************************************************

	template jabber_client.Message  tr_CompMessage_cancel_requestor_request(Node pl_node, XSD.Name pl_sessionId, XSD.String pl_actionId):=
	{
		from_ := omit,
		id := "cancel_request_" & pl_actionId,
		lang := "en",
		to_ := pl_node.nodeId,
		type_ := normal,
		choice_list := {},
		elem_list :=
		{
			oct2char(enc_Cancel(valueof(t_harness_cancel(pl_sessionId, pl_actionId))))
		},
		error_ := omit
	} 
	
	template Cancel t_harness_cancel(XSD.Name pl_sessionId, XSD.String pl_actionId) := 
	{
		requestId := "performing_action_" & pl_actionId,
		session := pl_sessionId,
		timestamp := omit
	}

//****** Result ***************************************************************************************	
	
	template CompositeClientMessage  tr_CompMessage_cancel_response(Node pl_node, XSD.Name pl_sessionId, XSD.String pl_actionId):=
	{
		from_ := *,
		id := "performing_action_" & pl_actionId,
		lang := *,
		to_ := ?,
		type_ := normal ,
		choice_list := { },
		elem_list :=
		{
			{
				harness_response :=
				{
					lang := *,
					requestId := "performing_action_" & pl_actionId,
					session := pl_sessionId,
					result := abort,
					message_ := *,
					duration := *,
					item_list := {},
					xmlItem_list := {},
					file_list := {},
					group_list := {},
					timestamp := *
				}
			}
		},
		error_ := omit
	}
	
	template CompositeClientMessage  tr_CompMessage_cancel_response_fail(Node pl_node, XSD.Name pl_sessionId, XSD.String pl_actionId):=
	{
		from_ := *,
		id := "performing_action_" & pl_actionId,
		lang := *,
		to_ := pl_node.nodeId,
		type_ := normal ,
		choice_list := { },
		elem_list :=
		{
			{
				harness_response :=
				{
					lang := *,
					requestId := "performing_action_" & pl_actionId,
					session := pl_sessionId,
					result := fail_,
					message_ := *,
					duration := *,
					item_list := {},
					xmlItem_list := {},
					file_list := {},
					group_list := {},
					timestamp := *
				}
			}
		},
		error_ := omit
	}

//*****************************************************************************************************
//Progress update
//*****************************************************************************************************

//****** Result ***************************************************************************************

	template CompositeClientMessage tr_progress_update(Node pl_node, XSD.String pl_actionId, XSD.Name pl_sessionId) :=
	{
		from_ := pl_node.nodeId,
		id := ?,
		lang := *,
		to_ := *,
		type_ := ?,
		choice_list := { },
		elem_list :=
		{
			{
				harness_progress :=
				{
					requestId := "performing_action_" & pl_actionId,
					session := pl_sessionId,
					totalWork := ?,
					remainingWork := ?,
					status := *,
					timeRemaining := *,
					timestamp := *
				}
			}
		},
		error_ := omit
	}


//*****************************************************************************************************
//Notify-close message
//*****************************************************************************************************

//****** Result ***************************************************************************************

	template CompositeClientMessage tr_CompMessage_notify_close(Node pl_node, XSD.Name pl_sessionId) :=
	{
		from_ := pl_node.nodeId,
		id := *,
		lang := *,
		to_ := *,
		type_ := ?,
		choice_list := { },
		elem_list :=
		{
			{
				harness_notify_close :=
				{
					session := pl_sessionId,
					timestamp := *
				}
			}
		},
		error_ := omit
	}



//*************************************************************************
function f_mapParameterDeclaration2RequestParameter(  in  Query_harness p_harness, in integer p_index) return Request.parameter_list
//*************************************************************************

{   
  //p_harness.actionDecl_list[p_index].parameter_list[i]

  var Request.parameter_list v_req

 if(p_harness.actionDecl_list[p_index].parameter_list=={}) 
  {
v_req:={}; 
log("v_req",v_req);return v_req;   
  }


    for(var integer i := 0; i < sizeof(p_harness.actionDecl_list[p_index].parameter_list); i := i+1)
  {
    v_req[i].name:="";
    v_req[i].base:="";
  }


	log("v_req init",v_req)

  for(var integer i := 0; i < sizeof(p_harness.actionDecl_list[p_index].parameter_list); i := i+1)
  {
    if (ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].name))
    {
      v_req[i].name:=p_harness.actionDecl_list[p_index].parameter_list[i].name;
    }
    else 
    {
      v_req[i].name:="";  
    }

    if(ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].datatype)) 
    {
      //-----------------------------------------------------------------------------------------------
      if (p_harness.actionDecl_list[p_index].parameter_list[i].datatype==boolean_) 
      {
        //-----------------------------------------------------------------------------------------------


        if(not(ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].mandatory))  //mandatory field not present, assume true
          or (
            (ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].mandatory)) and (p_harness.actionDecl_list[p_index].parameter_list[i].mandatory) //mandatory list present, set to true
          )
        )

        {//generate value        

            if (2.0*rnd()>1.0) 
            {
              v_req[i].base:="true" ; log("v_req",v_req);return v_req;         
            }
            else 
            {
              v_req[i].base:="false" ; log("v_req",v_req);return v_req;   
            }


        }

        else //mandatory field present and false

        {//take default if applicable, else if empty , generate value

          if ((ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].default_)) and (p_harness.actionDecl_list[p_index].parameter_list[i].default_!=""))
          {
            v_req[i].base:=p_harness.actionDecl_list[p_index].parameter_list[i].default_ ; log("v_req",v_req);return v_req;    
          }
          else if ((ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].default_)) and (p_harness.actionDecl_list[p_index].parameter_list[i].default_==""))
          {//default unusable , generate value
              if (2.0*rnd()>1.0) 
            {
              v_req[i].base:="true" ; log("v_req",v_req);return v_req;         
            }
            else 
            {
              v_req[i].base:="false" ; log("v_req",v_req);return v_req;   
            }
          }
          else if (not(ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].default_))) 
            {
             v_req[i].base:="" ; log("v_req",v_req);return v_req;    

            }

        }

      }//endif datatype boolean
      //-----------------------------------------------------------------------------------------------

      if (p_harness.actionDecl_list[p_index].parameter_list[i].datatype==integer_) 
      //-----------------------------------------------------------------------------------------------

      {
        if(not(ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].mandatory))  //mandatory field not present, assume true
          or (
            (ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].mandatory)) and (p_harness.actionDecl_list[p_index].parameter_list[i].mandatory) //mandatory list present, set to true
          )
        )

        { //generate value       

          if(ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].allowedValue_list[0])) 
          {
		log("action number:" & int2str(p_index))
		log("parameter:" & int2str(i))
            v_req[i].base:=p_harness.actionDecl_list[p_index].parameter_list[i].allowedValue_list[0].base;//random index??
            return v_req;
          }

          if(ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].allowedRange_list[0]))   
          {
            v_req[i].base:=p_harness.actionDecl_list[p_index].parameter_list[i].allowedRange_list[0].min;//random index??random value between min and max??
            return v_req;

          }
          else 
          {
            //generate random integer
            // float2int(int2float(upperbound-lowerbound+1)*rnd()) +lowerbound 
            v_req[i].base:= int2str(float2int(int2float(10)*rnd()) +1); log("v_req",v_req);return v_req; 
          }

        }

        else //mandatory field present and false

        {//take default if applicable, else if  empty, generate value 

          if ((ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].default_)) and (p_harness.actionDecl_list[p_index].parameter_list[i].default_!=""))
          {
            v_req[i].base:=p_harness.actionDecl_list[p_index].parameter_list[i].default_ ; log("v_req",v_req);return v_req;    
          }
          else if ((ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].default_)) and (p_harness.actionDecl_list[p_index].parameter_list[i].default_==""))
          {//default unusable , generate value
              v_req[i].base:=int2str(float2int(int2float(10)*rnd()) +1);log("v_req",v_req);return v_req; 
          }
          else if (not(ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].default_))) 
            {
             v_req[i].base:="" ; log("v_req",v_req);return v_req;    

            }

        }



      }//endif datatype integer
      //-----------------------------------------------------------------------------------------------

      if (p_harness.actionDecl_list[p_index].parameter_list[i].datatype==string) 
      {
        //-----------------------------------------------------------------------------------------------

        if(not(ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].mandatory))  //mandatory filed not present, assume true
          or (
            (ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].mandatory)) and (p_harness.actionDecl_list[p_index].parameter_list[i].mandatory) //mandatory list present, set to true
          )
        )

        {  //generate value   ---check for allowedlength etc.!!!!!      
          v_req[i].base:= f_generate_random_string(6);
          return v_req;

        }

        else //mandatory field present and false

        {//take default if applicable, else if empty, generate value 
          if ((ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].default_)) and (p_harness.actionDecl_list[p_index].parameter_list[i].default_!=""))
          {
            v_req[i].base:=p_harness.actionDecl_list[p_index].parameter_list[i].default_ ; log("v_req",v_req);return v_req;    
          }
          else if ((ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].default_)) and (p_harness.actionDecl_list[p_index].parameter_list[i].default_==""))
          {//default unusable , generate value
            v_req[i].base:=f_generate_random_string(7);
            log("v_req",v_req);return v_req; 
          }
          else if (not(ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].default_))) 
            {
             v_req[i].base:="" ; log("v_req",v_req);return v_req;    
      
            }

        }



      }//endif datatype string



    }//endif datatype is present

    else { //datataype not present, assume datatype string?
	if(ispresent(p_harness.actionDecl_list[p_index].parameter_list[i].allowedValue_list[0])) 
	{
		log("action number:" & int2str(p_index))
		log("parameter:" & int2str(i))
		v_req[i].base:=p_harness.actionDecl_list[p_index].parameter_list[i].allowedValue_list[0].base;//random index??
		return v_req;
	}

    }

  }//endfor


  log("v_req",v_req);return v_req;               
}




//-----------------------------------------------------------------------------
function f_RequestorSendReceiveClientIq(in jabber_client.Iq  p_cIq, template CompositeClientIq t_receive, out CompositeClientIq pl_compcIq) runs on Requestor_CT return boolean
//-----------------------------------------------------------------------------

{//startfunction

	var CompositeClientIq vl_receivedIq;
	
	Comm_PCO.send(p_cIq);    
	TwaitSendReceive.start(20.0);

	alt
	{
            []TwaitSendReceive.timeout; { setverdict(fail);}
        	[]InComm_PCO.receive(t_receive) -> value vl_receivedIq
		{
                  TwaitSendReceive.stop;
                  pl_compcIq:= vl_receivedIq;
                  setverdict(pass);
			return true;
		}
			
		[]InComm_PCO.receive(CompositeClientIq:?) -> value vl_receivedIq
		{  
			TwaitSendReceive.stop;
                  pl_compcIq := vl_receivedIq;
			setverdict(fail);
			return false;
		}
		
        }
  	
  	return false;
  	
}//endfunction


//-----------------------------------------------------------------------------
function f_RequestorSendReceiveClientMessage(in jabber_client.Message  p_cMessage, template CompositeClientMessage t_receive, out CompositeClientMessage pl_compcMessage) runs on Requestor_CT return boolean
//-----------------------------------------------------------------------------

{//startfunction

	var CompositeClientMessage vl_receivedMessage;
	
	Comm_PCO.send(p_cMessage);    
	Twait.start(3.0);

	alt
	{
            []Twait.timeout; { setverdict(fail);}
        	[]InComm_PCO.receive(t_receive) -> value vl_receivedMessage
		{
                  pl_compcMessage:= vl_receivedMessage;
                  setverdict(pass);
                  Twait.stop;
			return true;
		}
			
		[]InComm_PCO.receive(CompositeClientMessage:?) -> value vl_receivedMessage
		{
			setverdict(fail);  
			Twait.stop;
			
			if(vl_receivedMessage.error_ == omit and vl_receivedMessage.type_ != error_)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
        }
  	
  	return false;
  	
}//endfunction


//-----------------------------------------------------------------------------
function f_RequestorSendReceiveClientIqPresenceOpen(in jabber_client.Iq  p_cIq, in XSD.String pl_openId, out CompositeClientIq pl_compcIq) runs on Requestor_CT return boolean
//-----------------------------------------------------------------------------
{
	var charstring vl_char;
	var CompositeClientIq vl_receivedIq;
	var CompositeClientMessage vl_receivedMessage;
      var jabber_client.Presence vl_receivedPresence;
        
	
	Comm_PCO.send(p_cIq);    
	Twait.start(5.0);

	alt
	{
            []Twait.timeout; { setverdict(fail);}
                
        	[]InComm_PCO.receive(jabber_client.Presence: ?) -> value vl_receivedPresence
		{
			vl_char:=oct2char(enc_cPresence(vl_receivedPresence));
			if(match(vl_char, t_RegExpPresenceNoSession))
			{
				Twait.stop;
				return true
			}
			repeat;
		}
		
		[]InComm_PCO.receive(tr_Iq_open_session_result_pass(pl_openId)) -> value pl_compcIq
		{
			Twait.stop;
			return false;
		}
        }
        
  	return false;
  	
}


//-----------------------------------------------------------------------------
function f_RequestorSendReceiveClientIqPresenceClose(in jabber_client.Iq  p_cIq, in XSD.String pl_openId, out CompositeClientIq pl_compcIq, XSD.String pl_sessionId) runs on Requestor_CT return boolean
//-----------------------------------------------------------------------------

{
	 var charstring vl_char;
	var CompositeClientIq vl_receivedIq;
	var CompositeClientMessage vl_receivedMessage;
      var jabber_client.Presence vl_receivedPresence;
        
	
	Comm_PCO.send(p_cIq);    
	Twait.start(5.0);

	alt
	{
            []Twait.timeout; { setverdict(fail);}
                
        	[]InComm_PCO.receive(jabber_client.Presence: ?)
		{
			setverdict(pass);
			Twait.stop;
			return true;
		}
		[]InComm_PCO.receive(tr_Iq_close_session_result(pl_sessionId, pl_openId))
		{
			repeat;
		}
		[]InComm_PCO.receive(tr_Iq_close_session_result_fail(pl_sessionId, pl_openId))
		{
			log("Session could not be closed")
			setverdict(fail);
			Twait.stop;
			
			return(false);
		}
        }
        
  	return false;
}

//************************************************************************* 
function f_StoreActivationRefProxy(inout Node pl_node, CompositeClientMessage pl_resultMessage, integer pl_activationNr) runs on Requestor_CT
//*************************************************************************
{
	pl_node.listOfActivations[pl_activationNr].activate_ := pl_resultMessage.elem_list[0].activation_activate;
	pl_node.listOfActivations[pl_activationNr].sessionId_List := {};
}

//************************************************************************* 
function f_StoreActivationRef(inout Node pl_node, CompositeClientIq pl_resultIq, integer pl_activationNr) runs on Requestor_CT
//*************************************************************************
{
	pl_node.listOfActivations[pl_activationNr].activate_ := pl_resultIq.elem.activation_activate;
	pl_node.listOfActivations[pl_activationNr].sessionId_List := {};
}


//************************************************************************* 
function  f_StoreSession(CompositeClientIq pl_resultIq, integer pl_nodeNr, integer pl_activationNr, integer pl_sessionNr) runs on Requestor_CT
//*************************************************************************
{
	v_ntafNodes[pl_nodeNr].listOfActivations[pl_activationNr].sessionId_List[pl_sessionNr] := pl_resultIq.elem.harness_response.session;
}

//************************************************************************* 
function  f_DeleteLastSessionId(integer pl_nodeNr, integer pl_activationNr, integer pl_sessionNr) runs on Requestor_CT return integer
//*************************************************************************
{
	v_ntafNodes[pl_nodeNr].listOfActivations[pl_activationNr].sessionId_List[pl_sessionNr]:= "";
	return (pl_sessionNr - 1);
}


//Disco#items
//************************************************************************* 
function  f_StoreToolNodes(CompositeClientIq pl_resultIq) runs on Requestor_CT
//*************************************************************************
{
	var integer vl_nrOfToolNodes := 0;
	
	vl_nrOfToolNodes := sizeof(pl_resultIq.elem.items_query.sequence.item_list);
	
	for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfToolNodes; vl_nodeNr := vl_nodeNr + 1)
	{
		if(pl_resultIq.from_ == pl_resultIq.elem.items_query.sequence.item_list[vl_nodeNr].jid)
		{
			v_list_of_tool_nodes[vl_nodeNr] := pl_resultIq.elem.items_query.sequence.item_list[vl_nodeNr].node;
		}
		else
		{
			v_list_of_tool_nodes[vl_nodeNr] := pl_resultIq.elem.items_query.sequence.item_list[vl_nodeNr].jid;
		}
		
	}
}

//Disco#info
//************************************************************************* 
function  f_StoreDiscoInfo(CompositeClientIq pl_resultIq, integer pl_nodeNr) runs on Requestor_CT
//*************************************************************************
{
	var integer vl_nrOfFeatures := 0;
	if(isbound(pl_resultIq.elem.info_query))
	{
		vl_nrOfFeatures := sizeof(pl_resultIq.elem.info_query.sequence.feature_list)
	}
	
	for(var integer vl_featureNr := 0; vl_featureNr < vl_nrOfFeatures; vl_featureNr := vl_featureNr + 1)
	{
		v_ntafNodes[pl_nodeNr].listOfFeatures[vl_featureNr] := pl_resultIq.elem.info_query.sequence.feature_list[vl_featureNr].var_;
	}
}


//************************************************************************* 
function f_StoreHarnesses(CompositeClientIq pl_resultIq, integer pl_toolNr, integer pl_storedToolNr) runs on Requestor_CT
//*************************************************************************
{
	//if node is proxy, saving all it's items as a new individual node, without a nodeId (it will be known after activation), with it's itemd
	var boolean proxy := false;
	if(proxy)	//pl_resultIq.elem.pubsub_pubsub.choice.choice_list[0].items.max_items != 1)
	{
		v_ntafNodes[pl_storedToolNr].proxy := true;
		v_ntafNodes[pl_storedToolNr].proxy_jid := pl_resultIq.elem.pubsub_pubsub.choice.choice_list[0].items.node;
		v_ntafNodes[pl_storedToolNr].itemId := pl_resultIq.elem.pubsub_pubsub.choice.choice_list[0].items.item_list[pl_toolNr].id;
			
		//this will be replaced after activation when the real jid is received:
		v_ntafNodes[pl_storedToolNr].nodeId := omit;			
		
		var Entry vl_itemEntry := dec_Entry(char2oct(unichar2char(valueof(pl_resultIq.elem.pubsub_pubsub.choice.choice_list[0].items.item_list[pl_toolNr].sequence.elem))));
		var integer vl_nrOfHarnesses := sizeof(vl_itemEntry.harness_list);
		
		for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
		{
			v_ntafNodes[pl_storedToolNr].harnesses[vl_harnessNr].harness := vl_itemEntry.harness_list[vl_harnessNr];
			v_ntafNodes[pl_storedToolNr].harnesses[vl_harnessNr].action_list :=
			{
					harness := "http://anyUri>",
					lang := "en",
					label_ := "",
					tooltip := omit,
					description := omit,
					helpURI := omit,
					supercedes := omit,
					author := omit,
					actionDecl_list := {},
					eventDecl_list := {}
			};
			v_ntafNodes[pl_storedToolNr].harnesses[vl_harnessNr].subharnessList := {};
		}
	}
	else
	{
		v_ntafNodes[pl_storedToolNr].proxy := false;
		v_ntafNodes[pl_storedToolNr].nodeId := pl_resultIq.elem.pubsub_pubsub.choice.choice_list[0].items.node;
		v_ntafNodes[pl_storedToolNr].itemId := pl_resultIq.elem.pubsub_pubsub.choice.choice_list[0].items.item_list[pl_toolNr].id;
		v_ntafNodes[pl_storedToolNr].proxy_jid := omit;
		
		var Entry vl_itemEntry := dec_Entry(char2oct(unichar2char(valueof(pl_resultIq.elem.pubsub_pubsub.choice.choice_list[0].items.item_list[pl_toolNr].sequence.elem))));
	
		var integer vl_nrOfHarnesses := sizeof(vl_itemEntry.harness_list);
		for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
		{
			v_ntafNodes[pl_storedToolNr].harnesses[vl_harnessNr].harness := vl_itemEntry.harness_list[vl_harnessNr];
			v_ntafNodes[pl_storedToolNr].harnesses[vl_harnessNr].action_list :=
			{
					harness := "http://anyUri>",
					lang := "en",
					label_ := "",
					tooltip := omit,
					description := omit,
					helpURI := omit,
					supercedes := omit,
					author := omit,
					actionDecl_list := {},
					eventDecl_list := {}
			};
			v_ntafNodes[pl_storedToolNr].harnesses[vl_harnessNr].subharnessList := {};
		}

	}
	
	v_ntafNodes[pl_storedToolNr].listOfActivations := {};
	v_ntafNodes[pl_storedToolNr].listOfFeatures := {};
	v_ntafNodes[pl_storedToolNr].listOfResources := {};
	
}


//************************************************************************* 
function  f_StoreActions(CompositeClientIq pl_resultIq, integer pl_nodeNr, integer pl_harnessNr) runs on Requestor_CT
//*************************************************************************
{
	if(isbound(pl_resultIq.elem.harness_query_harness))
	{
		v_ntafNodes[pl_nodeNr].harnesses[pl_harnessNr].action_list := pl_resultIq.elem.harness_query_harness;
		
		if(ispresent(pl_resultIq.elem.harness_query_harness.subharness_list))
		{
			var integer vl_nrOfSubharnesses := sizeof(pl_resultIq.elem.harness_query_harness.subharness_list)
			for(var integer vl_subharnessNr := 0; vl_subharnessNr < vl_nrOfSubharnesses; vl_subharnessNr := vl_subharnessNr + 1)
			{
				v_ntafNodes[pl_nodeNr].harnesses[pl_harnessNr].subharnessList[vl_subharnessNr] := pl_resultIq.elem.harness_query_harness.subharness_list[vl_subharnessNr];
			}
		}
	}
}


//Checks if the resource reported by a node has already been saved for an other node
//************************************************************************* 
function f_NewResource(XSD.String pl_resource) runs on Requestor_CT return boolean
//*************************************************************************
{
	var boolean vl_newResource := true;

	var integer vl_nrOfNodes := sizeof(v_ntafNodes);
	for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
	{
		var integer vl_nrOfResources := sizeof(v_ntafNodes[vl_nodeNr].listOfResources);
		for(var integer vl_resourceNr := 0; vl_resourceNr < vl_nrOfResources; vl_resourceNr := vl_resourceNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].listOfResources[vl_resourceNr].resourceName == pl_resource)
			{
				vl_newResource := false;
			}
		}
	}
	
	return vl_newResource;
}

template XSD.String t_allowedResourceId := pattern "[a-zA-Z]+(\w|_)+";

//************************************************************************* 
function f_StoreResources(CompositeClientIq pl_resultIq, integer pl_nodeNr) runs on Requestor_CT
//*************************************************************************
{	
	var integer vl_nrOfResources := sizeof(pl_resultIq.elem.harness_response.item_list);
	for(var integer vl_resourceNr := 0; vl_resourceNr < vl_nrOfResources; vl_resourceNr := vl_resourceNr + 1)
	{
		var XSD.String vl_resource := pl_resultIq.elem.harness_response.item_list[vl_resourceNr].base;
		
		if(match(vl_resource, t_allowedResourceId))
		{
			//if it has not been saved, saving the resourceId
			if(f_NewResource(vl_resource) == true)
			{
				v_ntafNodes[pl_nodeNr].listOfResources[vl_resourceNr].resourceName := vl_resource;
			}
		}
		else
		{
			log("The resource id is not valid")
		}
	}
}

//************************************************************************* 
function f_StoreAttributes(CompositeClientIq pl_resultIq, integer pl_nodeNr, integer pl_resourceNr) runs on Requestor_CT
//*************************************************************************
{	
	var integer vl_nrOfAttributes := sizeof(pl_resultIq.elem.harness_response.group_list);
	for(var integer vl_attributeNr := 0; vl_attributeNr < vl_nrOfAttributes; vl_attributeNr := vl_attributeNr + 1)
	{
		v_ntafNodes[pl_nodeNr].listOfResources[pl_resourceNr].attributes[vl_attributeNr] := pl_resultIq.elem.harness_response.group_list[vl_attributeNr];
	}
}



template XSD.String t_allowedConnectorId := pattern "[a-zA-Z]+(\w|_)+";

//************************************************************************* 
function f_StoreConnectors(CompositeClientIq pl_resultIq, integer pl_nodeNr, integer pl_resourceNr) runs on Requestor_CT
//*************************************************************************
{	
	var integer vl_nrOfConnectors := sizeof(pl_resultIq.elem.harness_response.group_list);
	for(var integer vl_connectorNr := 0; vl_connectorNr < vl_nrOfConnectors; vl_connectorNr := vl_connectorNr + 1)
	{
		var XSD.Name vl_connector := pl_resultIq.elem.harness_response.group_list[vl_connectorNr].name;
		if(match(vl_connector, t_allowedResourceId))
		{
			var integer vl_nrOfSavedConnectors := sizeof(v_ntafNodes[pl_nodeNr].listOfResources[pl_resourceNr].connectors);
			for(var integer vl_savedConnectorNr := 0; vl_savedConnectorNr < vl_nrOfSavedConnectors; vl_savedConnectorNr := vl_savedConnectorNr + 1)
			{
				if(v_ntafNodes[pl_nodeNr].listOfResources[pl_resourceNr].connectors[vl_savedConnectorNr].name == vl_connector)
				{
					v_ntafNodes[pl_nodeNr].listOfResources[pl_resourceNr].connectors[vl_connectorNr] := pl_resultIq.elem.harness_response.group_list[vl_connectorNr];
				}
				else
				{
					log("Duplicate connector id")
				}
			}
		}
		else
		{
			log("The connector id is not valid")
		}
	}	
}


//*************************************************************************
function f_NotSupported(Node pl_node, integer pl_harnessNr) return SessionMode
//*************************************************************************
{
	var integer vl_nrOfSupportedModes := sizeof(pl_node.harnesses[pl_harnessNr].harness.supportedMode_list);
	if(vl_nrOfSupportedModes == 1)
	{
		if(pl_node.harnesses[pl_harnessNr].harness.supportedMode_list[0] == invisible_and_automated or pl_node.harnesses[pl_harnessNr].harness.supportedMode_list[0] == visible_and_automated)
		{
			return visible_and_interactive;
		}else
		{
			return invisible_and_automated;
		}
	}
	else
	{
		if(pl_node.harnesses[pl_harnessNr].harness.supportedMode_list[0] == invisible_and_automated)
		{
			if(pl_node.harnesses[pl_harnessNr].harness.supportedMode_list[1] == visible_and_automated)
			{
				return visible_and_interactive;
			}else{
				return visible_and_automated;
			}
		}
		else if(pl_node.harnesses[pl_harnessNr].harness.supportedMode_list[0] == visible_and_automated)
		{
			if(pl_node.harnesses[pl_harnessNr].harness.supportedMode_list[1] == invisible_and_automated)
			{
				return visible_and_interactive;
			}else{
				return invisible_and_automated;
			}
		}
		else
		{
			if(pl_node.harnesses[pl_harnessNr].harness.supportedMode_list[1] == invisible_and_automated)
			{
				return visible_and_automated;
			}else{
				return invisible_and_automated;
			}
		}
	}
}



//************************************************************************* 
function f_TS001_preamble() runs on Requestor_CT return boolean
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var integer vl_storedNodeNr := 0;

	if(f_RequestorSendReceiveClientIq(valueof(t_Iq_get_ntaf_node_info), tr_Iq_get_ntaf_node_info_response, vl_resultClientIq))
	{
		//disco#items
		f_RequestorSendReceiveClientIq(valueof(t_Iq_get_nodes), tr_Iq_get_nodes_result, vl_resultClientIq);
		
		log(vl_resultClientIq)
		
		if(ispresent(vl_resultClientIq.elem.items_query.sequence))
		{
			f_StoreToolNodes(vl_resultClientIq);
		}
		
		
		var boolean vl_delete_node := false;
		var integer vl_nrOfNodes := sizeof(v_list_of_tool_nodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_list_of_tool_nodes[vl_nodeNr] == tsp_username_requestor&"@"&tsp_fqdn&"/"&tsp_resource)
			{
				vl_delete_node := true;
			}
		}
		
		if(vl_delete_node == true)
		{	
			log("********************************************")
			log("Deleting leaf requestor")
			log("********************************************")
			f_RequestorSendReceiveClientIq(valueof(t_Iq_remove_leaf_node_requestor), tr_CompIq_delete_leaf_node_result, vl_resultClientIq);
		}
		
		f_RequestorSendReceiveClientIq(valueof(t_Iq_create_leaf_node_requestor), tr_CompIq_create_leaf_node_result, vl_resultClientIq);
		
		//pubsub
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_list_of_tool_nodes[vl_nodeNr] !=  tsp_username_requestor&"@"&tsp_fqdn&"/"&tsp_resource)
			{
				var boolean vl_pubsubOk := false;
				vl_pubsubOk := f_RequestorSendReceiveClientIq(valueof(t_Iq_fetch_tool_registry_request(v_list_of_tool_nodes, vl_nodeNr)), 														tr_fetch_tool_registry_result(v_list_of_tool_nodes, vl_nodeNr), vl_resultClientIq);
				if(vl_pubsubOk)
				{
					var integer vl_nrOfTools := sizeof(vl_resultClientIq.elem.pubsub_pubsub.choice.choice_list[0].items.item_list)
					for(var integer vl_toolNr := 0; vl_toolNr < vl_nrOfTools; vl_toolNr := vl_toolNr + 1)
					{
						f_StoreHarnesses(vl_resultClientIq, vl_toolNr, vl_storedNodeNr);
						vl_storedNodeNr := vl_storedNodeNr + 1;
					}
				}
			}
		}
		
		return true;
	}
	else{ return false; }
}

//************************************************************************* 
function f_TS001_postamble() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	f_RequestorSendReceiveClientIq(valueof(t_Iq_remove_leaf_node_requestor), tr_CompIq_delete_leaf_node_result, vl_resultClientIq);
}

//*************************************************************************
function f_TS002_preamble() runs on Requestor_CT return boolean
//*************************************************************************
{
	//tsp_ts002_preamble is false, this function will simply return true without checking if features returned in an answer for disco info contains all the harnesses published
	if(tsp_ts002_preamble)
	{
		var boolean vl_harnessFoundInFeatureList := false;
		var boolean vl_allHarnessesOk := true;
	
		f_TS002_disco_info()
		
		var integer vl_nrOfNodes := sizeof(v_ntafNodes)
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses)
			for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var integer vl_nrOfFeatures := sizeof(v_ntafNodes[vl_nodeNr].listOfFeatures)
				for(var integer vl_featureNr := 0; vl_featureNr < vl_nrOfFeatures; vl_featureNr := vl_featureNr + 1)
				{
					if(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name == v_ntafNodes[vl_nodeNr].listOfFeatures[vl_featureNr])
					{
						vl_harnessFoundInFeatureList := true;
					}
				}
		
				if(vl_harnessFoundInFeatureList != true)
				{
					vl_allHarnessesOk := false;
				}
		
				vl_harnessFoundInFeatureList := false;
			}
		}
	
		if(vl_allHarnessesOk)
		{
			setverdict(pass);
		}else{
			setverdict(fail);
		}
	
		return vl_allHarnessesOk;
	}
	else
	{
		return true;
	}
}

//************************************************************************* 
function  f_TS002_disco_info() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	
	var integer vl_nrOfNodes := sizeof(v_ntafNodes);
	for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
	{
		var Node vl_node := v_ntafNodes[vl_nodeNr];
		var boolean vl_discoInfo := false;
		vl_discoInfo := f_RequestorSendReceiveClientIq(valueof(ts_Iq_disco_info_provider_request(vl_node, vl_nodeNr)), tr_CompIq_disco_info_result_harness(vl_node, vl_nodeNr), 																												vl_resultClientIq);
		
		if(vl_discoInfo)
		{
			f_StoreDiscoInfo(vl_resultClientIq, vl_nodeNr);
		}
	}
}

//************************************************************************* 
function f_TS002_query_harness() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	
	var integer vl_nrOfNodes := sizeof(v_ntafNodes);
	for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
	{
		var Node vl_node := v_ntafNodes[vl_nodeNr];
	
		var integer vl_nrOfHarnesses := sizeof(vl_node.harnesses);
		for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
		{
			var Harness vl_harness := vl_node.harnesses[vl_harnessNr].harness;
			f_RequestorSendReceiveClientIq(valueof(ts_Iq_query_harness_provider_request(vl_node, vl_harness, vl_nodeNr, vl_harnessNr)), 													ts_Iq_query_harness_provider_request_result(vl_node, vl_harness, vl_nodeNr, vl_harnessNr), vl_resultClientIq);
			f_StoreActions(vl_resultClientIq, vl_nodeNr, vl_harnessNr);
		}
	}
}


//************************************************************************* 
function f_ActivateTool(inout Node pl_node, XSD.String pl_nodeId, XSD.String pl_toolId, XSD.String pl_harness, SessionMode pl_supportedMode, XSD.String pl_activationId, 							out CompositeClientIq pl_resultIq, out CompositeClientMessage pl_resultMessage, integer pl_nrOfActivations) runs on Requestor_CT return boolean
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_resultClientMessage;

	var boolean vl_activationSuccessful := false;
	if(pl_node.proxy == true)
	{
		var boolean vl_activationPending;
		
		vl_activationPending := f_RequestorSendReceiveClientIq(valueof(ts_Iq_activate_always_on_tool_request(pl_nodeId, pl_toolId, pl_harness, pl_supportedMode, pl_activationId)), 																	tr_CompIq_request_Activate_request_pending(pl_nodeId, pl_activationId), vl_resultClientIq);
		if(isbound(vl_resultClientIq))
		{
			pl_resultIq := vl_resultClientIq;
		}
		
		if(pl_resultIq.elem.activation_activate.result == pass_ and pl_resultIq.error_ == omit)
		{
			f_StoreActivationRef(pl_node, pl_resultIq, pl_nrOfActivations);
			pl_node.nodeId := pl_node.proxy_jid;
		}
		else if(vl_activationPending)
		{							
			var XSD.String vl_requestId := vl_resultClientIq.id;
			Twait2.start(20.0);
			alt
			{
				[]Twait.timeout; { setverdict(fail); }
		
				[]InComm_PCO.receive(tr_CompMessage_request_Activate_request_pass(pl_nodeId, pl_toolId, vl_requestId, pl_activationId)) -> value vl_resultClientMessage
				{
					pl_resultMessage := vl_resultClientMessage;
					setverdict(pass);
					vl_activationSuccessful := true;
					Twait.stop;
				}
			}
		}
	}
	else
	{
		vl_activationSuccessful := f_RequestorSendReceiveClientIq(valueof(ts_Iq_activate_always_on_tool_request(pl_nodeId, pl_toolId, pl_harness, pl_supportedMode, 														pl_activationId)), tr_CompIq_request_Activate_request_pass(pl_toolId, pl_activationId), vl_resultClientIq);
		if(isbound(vl_resultClientIq))
		{
			pl_resultIq := vl_resultClientIq;
		}
	}

	if(vl_activationSuccessful)
	{	
	//---------------------------------------------------------------------------------------------------------------------------------------------------------
		if(pl_node.proxy == true)
		{
			f_StoreActivationRefProxy(pl_node, pl_resultMessage, pl_nrOfActivations);
			
			var XSD.String vl_proxyId := pl_nodeId;						//proxy jid(pl_nodeId) will not be used from now on, except for deactivation
			pl_node.nodeId := pl_resultMessage.elem_list[0].activation_activate.jid;
			
		}else{
			f_StoreActivationRef(pl_node, pl_resultIq, pl_nrOfActivations);
			log(pl_node)
		}
		
	//---------------------------------------------------------------------------------------------------------------------------------------------------------
	}
	
	return vl_activationSuccessful;
}



//************************************************************************* 
function f_DeactivateTool(Node pl_node, XSD.String pl_activationId, XSD.String pl_activationRef, out CompositeClientIq pl_resultIq) runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var XSD.String pl_nodeId := "";

	if(pl_node.proxy == true)
	{
		var XSD.String vl_proxyId := pl_node.proxy_jid;
		pl_nodeId := pl_node.nodeId;
		
		//deactivation sent to the proxy
		f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(pl_activationRef, vl_proxyId, pl_activationId)),
										tr_CompIq_deactivate_result(pl_activationRef, pl_activationId), vl_resultClientIq);
		if(isbound(vl_resultClientIq))
		{
			pl_resultIq := vl_resultClientIq;
		}
	}
	
	//deactivation sent to the tool itself
	pl_nodeId := pl_node.nodeId;
	f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(pl_activationRef, pl_nodeId, pl_activationId)), 														tr_CompIq_deactivate_result(pl_activationRef, pl_activationId), vl_resultClientIq);
	if(isbound(vl_resultClientIq))
	{
		pl_resultIq := vl_resultClientIq;
	}
}



//************************************************************************* 
function  f_TS001_act_deact_separately() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
	
		//number of ntaf.tools child nodes
		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
		
			//number of harnesses for a given node
			var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
				//number of supportedModes for a given harness
				var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
				for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
				{
					var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
				
					var boolean vl_activationSuccessful;
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
								
					if(v_ntafNodes[vl_nodeNr].proxy == true)
					{
						//=======================================================================================================================================	
						var boolean vl_activationPending;
						vl_activationPending := f_RequestorSendReceiveClientIq(valueof(ts_Iq_activate_always_on_tool_request(vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, 														vl_activationId)), tr_CompIq_request_Activate_request_pending(vl_nodeId, vl_activationId), vl_resultClientIq);
						if(isbound(vl_resultClientIq))
						{
							if(vl_resultClientIq.elem.activation_activate.result == pass_ and vl_resultClientIq.error_ == omit)
							{
								vl_activationRef := vl_resultClientIq.elem.activation_activate.activationRef;
								f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_activationRef, vl_nodeId, vl_activationId)),
																	tr_CompIq_deactivate_result(vl_activationRef, vl_activationId), vl_resultClientIq);
							}
							else if(vl_activationPending)
							{
								log("Activation is pending, waiting for pass message")
							
								vl_activationSuccessful := false;
							
								var XSD.String vl_requestId := vl_resultClientIq.id;
							
								Twait.start(20.0);
								alt
								{
									[]Twait.timeout; { setverdict(fail); }
							
									[]InComm_PCO.receive(tr_CompMessage_request_Activate_request_pass(vl_nodeId, vl_toolId, vl_requestId, vl_activationId)) -> 																													value vl_receivedMessage
									{
										setverdict(pass);
										vl_activationSuccessful := true;
										Twait.stop;
									}
								}						
						
								if(vl_activationSuccessful or (vl_resultClientIq.elem.activation_activate.result == pass_ and vl_resultClientIq.error_ == omit))
								{
									vl_activationRef := vl_receivedMessage.elem_list[0].activation_activate.activationRef;
									v_ntafNodes[vl_nodeNr].nodeId := vl_receivedMessage.elem_list[0].activation_activate.jid;
									var XSD.String vl_proxyId := vl_nodeId;				//proxy jid will not be used from now on, except for deactivation
									vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;			//tool jid received after activation
								
									//deactivation sent to the proxy
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_activationRef, vl_proxyId, vl_proxyId)),
																	tr_CompIq_deactivate_result(vl_activationRef, vl_activationId), vl_resultClientIq);
																
									//deactivation sent to the tool itself
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_activationRef, vl_nodeId, vl_toolId)),
																	tr_CompIq_deactivate_result(vl_activationRef, vl_activationId), vl_resultClientIq);
								}
							}
						}
						//=======================================================================================================================================
					}
					else
					{
						vl_activationSuccessful := f_RequestorSendReceiveClientIq(valueof(ts_Iq_activate_always_on_tool_request(vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, 														vl_activationId)), tr_CompIq_request_Activate_request_pass(vl_toolId, vl_activationId), vl_resultClientIq);
	
						if(vl_activationSuccessful or (vl_resultClientIq.elem.activation_activate.result == pass_ and vl_resultClientIq.error_ == omit))
						{
							vl_activationRef := vl_resultClientIq.elem.activation_activate.activationRef;
					
							f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_activationRef, vl_nodeId, vl_activationId)),
															tr_CompIq_deactivate_result(vl_activationRef, vl_activationId), vl_resultClientIq);
						}
					}
				}
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();		
	}
	

	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}

//************************************************************************* 
function  f_TS001_act_deact_altogether() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_resultClientMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
		
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
		
		//number of ntaf.tools child nodes
		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
			//number of harnesses for a given node
			var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
				//number of supportedModes for a given harness
				var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
				for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
				{										
					var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
										
					var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_resultClientMessage, vl_nrOfActivations);
					
					vl_nrOfActivations := vl_nrOfActivations + 1;
				}
			}
			vl_nrOfActivations := 0;
		}

		vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	}
	
	Ctl_PCO.send("halt");

	deactivate(v_reqDefault);
}



//************************************************************************* 
function f_TS002_disco_info_query_harness() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var NTAF_templates.AnyType vl_resultElem;
	var universal charstring vl_activationRef := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
		
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
		
		if(f_TS002_preamble())
		{
			f_TS002_query_harness()
		
			log(v_ntafNodes)
		}
	
		log("######################################## start of postamble ########################################")
	
		f_TS001_postamble();
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function f_TS002_open_session_separately() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
				
						var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
						
						var boolean vl_activationSuccessful := false;
						if(v_ntafNodes[vl_nodeNr].proxy == true)
						{
						//=======================================================================================================================================	
							
							var boolean vl_activationPending;
							vl_activationPending := f_RequestorSendReceiveClientIq(valueof(ts_Iq_activate_always_on_tool_request(vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, 														vl_activationId)), tr_CompIq_request_Activate_request_pending(vl_nodeId, vl_activationId), vl_resultClientIq);
							if(vl_activationPending)
							{						
								var XSD.String vl_requestId := vl_resultClientIq.id;
								
								Twait.start(20.0);
								alt
								{
									[]Twait.timeout; { setverdict(fail); }
						
									[]InComm_PCO.receive(tr_CompMessage_request_Activate_request_pass(vl_nodeId, vl_toolId, vl_requestId, vl_activationId)) -> 																											value vl_receivedMessage
									{
										setverdict(pass);
										vl_activationSuccessful := true;
										Twait.stop;
									}
								}						
					
								if(vl_activationSuccessful)
								{
									vl_activationRef := vl_receivedMessage.elem_list[0].activation_activate.activationRef;
									v_ntafNodes[vl_nodeNr].nodeId := vl_receivedMessage.elem_list[0].activation_activate.jid;
									var XSD.String vl_proxyId := vl_nodeId;						//proxy jid will not be used from now on, except for deactivation
									vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;			//tool jid received after activation
							
									var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 															vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
									var XSD.Name vl_sessionId := vl_resultClientIq.elem.harness_response.session;

									if(vl_sessionOpened)
									{
										f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId,vl_activationId)), 																tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
									}
							
									//deactivation sent to the proxy
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_activationRef, vl_proxyId, vl_toolId)),
																	tr_CompIq_deactivate_result(vl_activationRef, vl_activationId), vl_resultClientIq);
															
									//deactivation sent to the tool itself
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_activationRef, vl_nodeId, vl_toolId)),
																	tr_CompIq_deactivate_result(vl_activationRef, vl_activationId), vl_resultClientIq);
								}
							}
						//=======================================================================================================================================
						}
						else
						{
							log("Activating non-proxy tool")
							vl_activationSuccessful := f_RequestorSendReceiveClientIq(valueof(ts_Iq_activate_always_on_tool_request(vl_nodeId, vl_toolId, vl_harness, 											vl_supportedMode, vl_activationId)), tr_CompIq_request_Activate_request_pass(vl_toolId, vl_activationId), vl_resultClientIq);

							if(vl_activationSuccessful)
							{
								vl_activationRef := vl_resultClientIq.elem.activation_activate.activationRef;
				
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 															vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
								var XSD.Name vl_sessionId := vl_resultClientIq.elem.harness_response.session;

								if(vl_sessionOpened)
								{
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId,vl_activationId)), 																tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
								}
			
								f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_activationRef, vl_nodeId, vl_activationId)),
																tr_CompIq_deactivate_result(vl_activationRef, vl_activationId), vl_resultClientIq);
							}
						}
					}
				}
			}
		}
	}
	
	log("######################################## start of postamble ########################################")
	
	f_TS001_postamble();
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}



//************************************************************************* 
function  f_TS002_open_session_altogether() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	
	
	if(f_TS001_preamble())
	{
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{										
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
					
						var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
					
						var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
									
						if(vl_activationSuccessful)
						{	
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
							vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
							var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
							if(vl_sessionOpened)
							{							
								f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
								log(v_ntafNodes[vl_nodeNr])
							}
						
							vl_nrOfActivations := vl_nrOfActivations + 1;
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
						}
					}
				}
				vl_nrOfActivations := 0;
			}

			vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
				vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
				for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
				{
					vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
					var integer vl_nrOfSessionIds := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].sessionId_List);
					for(var integer vl_sessionNr := 0; vl_sessionNr < vl_nrOfSessionIds; vl_sessionNr := vl_sessionNr + 1)
					{
						var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].sessionId_List[vl_sessionNr];
						f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), tr_Iq_close_session_result(vl_sessionId, 																									vl_activationId),	vl_resultClientIq);
					}
				
					f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
				}
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS002_user_activity_notification() runs on Requestor_CT
//*************************************************************************
{
	
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{										
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
					
						var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
					
						var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
					
						
						if(vl_activationSuccessful)
						{	
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
					
							vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;	
							var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
							if(vl_sessionOpened)
							{						
								f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
						
								var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions];

			                                              action("===========================USER ACTION REQUIRED==================================="	)    
			                                              action("Please send notify action message for harness :" & vl_harness				)
			                                              action("mode : visible_and_interactive"									) 
			                                              action("=================================================================================="	)  

								Twait.start(2.0)
								alt
								{
									[]Twait.timeout; { setverdict(fail); }
									[]InComm_PCO.receive(tr_Message_notify_action(vl_sessionId)) -> value vl_receivedMessage
									{
										setverdict(pass);
										Twait.stop;
									}
								}
					
								f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 																	tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
							}
						
							vl_nrOfActivations := vl_nrOfActivations + 1;
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
						}
					}
				}
				vl_nrOfActivations := 0;
			}

			vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
				vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
				for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
				{
					vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
					f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
				}
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS002_notify_close() runs on Requestor_CT
//*************************************************************************
{
	
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{										
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
						//if one of the node's harnesses support visible and interactive mode
						if(vl_supportedMode == visible_and_interactive)
						{				
							var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
					
							var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
						
							if(vl_activationSuccessful)
							{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 							
								vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
								if(vl_sessionOpened)
								{							
									f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
					
									var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions];
						
											    action("===========================USER ACTION REQUIRED==================================="	)
											    action("Please send notify-close message for harness : & vl_harness"				)
				                                              action("                  mode : visible_and_interactive"                                  	) 
				                                              action("=================================================================================="	)  

									 
									Twait.start(2.0)
									alt
									{
										[]Twait.timeout
										{
											setverdict(fail);
											f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 																		tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
										}
										[]InComm_PCO.receive(tr_CompMessage_notify_close(v_ntafNodes[vl_nodeNr], vl_sessionId)) -> value vl_receivedMessage
										{
											setverdict(pass);
											Twait.stop;
										}
							
									}
								}
							
								vl_nrOfActivations := vl_nrOfActivations + 1;
							
							//---------------------------------------------------------------------------------------------------------------------------------------------------------
							}
						}
					}
				}
				vl_nrOfActivations := 0;
			}

			vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
				vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
				for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
				{
					vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
					var integer vl_nrOfSessionIds := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].sessionId_List);
					
					f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
				}
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}

//************************************************************************* 
function  f_TS002_session_resource_availability() runs on Requestor_CT
//*************************************************************************
{	
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";

	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 

	if(f_TS001_preamble())
	{
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{										
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
				
						var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
				
						var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
				
				
						if(vl_activationSuccessful)
						{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 					
							vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
				
							Twait3.start(tsp_availabilityTimer);
							alt
							{
								[]Twait3.timeout; {setverdict(inconc);}
								[else]
								{
									var boolean vl_noSessionAvailableReceived := f_RequestorSendReceiveClientIqPresenceOpen(valueof(ts_Iq_open_session_requestor(vl_activationRef, 																	vl_nodeId, vl_harness, vl_supportedMode, vl_activationId)), vl_activationId, vl_resultClientIq);
								
						
									if(vl_noSessionAvailableReceived)
									{
										var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions-1];
										if(f_RequestorSendReceiveClientIqPresenceClose(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 																								vl_activationId, vl_resultClientIq, vl_sessionId))
										{
											vl_nrOfOpenedSessions := f_DeleteLastSessionId(vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
											Twait3.stop;
										}
									}
									else
									{
										log(vl_nrOfOpenedSessions)
										f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
										vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
									}
						
									repeat;
								}
							}
						
							vl_nrOfActivations := vl_nrOfActivations + 1;
							vl_nrOfOpenedSessions := 0;
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
						}
					}
				}
				vl_nrOfActivations := 0;
			}

			vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
				vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
				for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
				{
					vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
					var integer vl_nrOfSessionIds := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].sessionId_List);
			
					for(var integer vl_sessionNr := 0; vl_sessionNr < vl_nrOfSessionIds; vl_sessionNr := vl_sessionNr + 1)
					{
						log(vl_nrOfSessionIds)
						log(vl_sessionNr)
				
						var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].sessionId_List[vl_sessionNr];
						f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), tr_Iq_close_session_result(vl_sessionId, 																									vl_activationId),	vl_resultClientIq);
					}
				
					f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
				}
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);

}



//************************************************************************* 
function  f_TS002_performing_actions_invisible_and_automated() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			f_TS002_query_harness();
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{										
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
					
						//if one of the node's harnesses support invisible and automated mode
						if(vl_supportedMode == invisible_and_automated)
						{			
							var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
				
							var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
		
							if(vl_activationSuccessful)
							{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 							
								vl_nrOfOpenedSessions := 0;
						
								vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
									
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
								if(vl_sessionOpened)
								{
									f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
				
									var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions];
							
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
				
									log(v_ntafNodes)
								
									var integer vl_nrOfActions := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list);
									for(var integer vl_actionNr := 0; vl_actionNr < vl_nrOfActions; vl_actionNr := vl_actionNr + 1)
									{
										var XSD.String vl_actionId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr) & int2str(vl_actionNr);
										Comm_PCO.send(ts_Iq_perform_action(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_harnessNr, vl_actionNr, vl_actionId));    
										
										Twait.start(20.0);
										alt
										{
											[]Twait.timeout; { setverdict(fail);}
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pass_, vl_actionId))
											{
												setverdict(pass);
												Twait.stop;
											}
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pending, vl_actionId))
											{
												Twait2.start(10.0)
												alt
												{	
													[]Twait2.timeout { setverdict(fail); }
													[]InComm_PCO.receive(tr_Message_perform_action_response_pass(vl_sessionId, v_ntafNodes[vl_nodeNr], 																		vl_harnessNr, vl_actionNr, vl_actionId))
													{
														setverdict(pass);
														Twait2.stop;
													}
												
													[]InComm_PCO.receive(tr_progress_update(v_ntafNodes[vl_nodeNr], vl_actionId, vl_sessionId))
													{
														repeat;
													}
										
													[]InComm_PCO.receive(ts_Message_perform_action_response_event(vl_sessionId, v_ntafNodes[vl_nodeNr], 																		vl_harnessNr, vl_actionNr)) -> value vl_receivedMessage
													{
														var integer vl_nrOfEvents := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list);
														var boolean vl_event_is_ok := false;
														for(var integer vl_eventNr := 0; vl_eventNr < vl_nrOfEvents; vl_eventNr := vl_eventNr + 1)
														{
															var XSD.String vl_event := 																		v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list[vl_eventNr].name;
													
															if(vl_event == vl_receivedMessage.elem_list[0].harness_event.name)
															{
																vl_event_is_ok := true;
															}
														}
											
														if(vl_event_is_ok == false) { setverdict(fail)}
														repeat;
													}
												}
											}
			
											[]InComm_PCO.receive(CompositeClientIq:?)
											{
												setverdict(fail);  
												Twait.stop;
											}
										}
									}
								
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ end actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
					
									
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 														tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
									vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
								}
						
								vl_nrOfActivations := vl_nrOfActivations + 1;
							
							//---------------------------------------------------------------------------------------------------------------------------------------------------------
							}
						}
					}
				}
				vl_nrOfActivations := 0;
			}

			vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
				vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
				for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
				{
					vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
					f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
				}
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS002_performing_actions_cancelling() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var CompositeClientMessage vl_resultClientMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			f_TS002_query_harness();
			
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{										
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
					
						//if one of the node's harnesses support invisible and automated mode
						if(vl_supportedMode == invisible_and_automated)
						{		
							var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
					
							var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
						
					
							if(vl_activationSuccessful)
							{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 							
								vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
				
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
								if(vl_sessionOpened)
								{
									vl_nrOfOpenedSessions := 0;
							
									f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
					
									var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions];
							
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
			
						
									var integer vl_nrOfActions := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list);
									for(var integer vl_actionNr := 0; vl_actionNr < vl_nrOfActions; vl_actionNr := vl_actionNr + 1)
									{
										var XSD.String vl_actionId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr) & int2str(vl_actionNr);
										Comm_PCO.send(ts_Iq_perform_action(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_harnessNr, vl_actionNr, vl_actionId));    
								
										Twait.start(20.0);
										alt
										{
											[]Twait.timeout; { setverdict(fail); }
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pass_, vl_actionId))
											{
												setverdict(pass);
												Twait.stop;
											}
									
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pending, vl_actionId))
											{
												Comm_PCO.send(tr_CompMessage_cancel_requestor_request(v_ntafNodes[vl_nodeNr], vl_sessionId, vl_actionId));
												
												Twait2.start(10.0)
												alt
												{
													[]Twait2.timeout{ setverdict(fail); }
													
													[]InComm_PCO.receive(tr_CompMessage_cancel_response(v_ntafNodes[vl_nodeNr], vl_sessionId, vl_actionId))
													{
														setverdict(pass);
														Twait2.stop;
													}
													
													[]InComm_PCO.receive(tr_progress_update(v_ntafNodes[vl_nodeNr], vl_actionId, vl_sessionId))
													{
														repeat;
													}
										
													[]InComm_PCO.receive(ts_Message_perform_action_response_event(vl_sessionId, v_ntafNodes[vl_nodeNr], 																		vl_harnessNr, vl_actionNr)) -> value vl_receivedMessage
													{
														var integer vl_nrOfEvents := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list);
														var boolean vl_event_is_ok := false;
														for(var integer vl_eventNr := 0; vl_eventNr < vl_nrOfEvents; vl_eventNr := vl_eventNr + 1)
														{
															var XSD.String vl_event := 																		v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list[vl_eventNr].name;
													
															if(vl_event == vl_receivedMessage.elem_list[0].harness_event.name)
															{
																vl_event_is_ok := true;
															}
														}
											
														if(vl_event_is_ok == false) { setverdict(fail)}
														repeat;
													}
													[]InComm_PCO.receive
													{
														Twait2.stop;
														setverdict(fail);
													}
													
												}
												Twait.stop;
											}
			
											[]InComm_PCO.receive(CompositeClientIq:?)
											{
												setverdict(fail);  
												Twait.stop;
											}
										}
									}
								
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ end actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
					
									
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 														tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
									vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
								}
							
								vl_nrOfActivations := vl_nrOfActivations + 1;
							
							//---------------------------------------------------------------------------------------------------------------------------------------------------------
							}
						}
					}
				}
				vl_nrOfActivations := 0;
			}

			vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
				vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
				for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
				{
					vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
					f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
				}
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS002_performing_actions_visible_and_automated() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			f_TS002_query_harness();
			
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{										
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
					
						//if one of the node's harnesses support invisible and automated mode
						if(vl_supportedMode == visible_and_automated)
						{
							var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
					
							var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
				
							if(vl_activationSuccessful)
							{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 								
								vl_nrOfOpenedSessions := 0;
							
								vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
			
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
								if(vl_sessionOpened)
								{
									log(v_ntafNodes[vl_nodeNr])
									log(v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations])
									log(vl_nrOfOpenedSessions)
									
									f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
									
									log(v_ntafNodes[vl_nodeNr])
									var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions];
							
								//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
			
									var integer vl_nrOfActions := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list);
									for(var integer vl_actionNr := 0; vl_actionNr < vl_nrOfActions; vl_actionNr := vl_actionNr + 1)
									{
										var XSD.String vl_actionId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr) & int2str(vl_actionNr);
										Comm_PCO.send(ts_Iq_perform_action(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_harnessNr, vl_actionNr, vl_actionId));    
										
										Twait.start(20.0);
										alt
										{
											[]Twait.timeout; { setverdict(fail);}
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pass_, vl_actionId))
											{
												setverdict(pass);
												Twait.stop;
											}
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pending, vl_actionId))
											{
												log(tr_Message_perform_action_response_pass(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_harnessNr, vl_actionNr, vl_actionId))
												Twait2.start(10.0)
												alt
												{	
													[]Twait2.timeout {setverdict(fail);};
													[]InComm_PCO.receive(tr_Message_perform_action_response_pass(vl_sessionId, v_ntafNodes[vl_nodeNr], 																		vl_harnessNr, vl_actionNr, vl_actionId))
													{
														setverdict(pass);
														Twait2.stop;
													}
												
													[]InComm_PCO.receive(tr_progress_update(v_ntafNodes[vl_nodeNr], vl_actionId, vl_sessionId))
													{
														repeat;
													}
										
													[]InComm_PCO.receive(ts_Message_perform_action_response_event(vl_sessionId, v_ntafNodes[vl_nodeNr], 																		vl_harnessNr, vl_actionNr)) -> value vl_receivedMessage
													{
														var integer vl_nrOfEvents := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list);
														var boolean vl_event_is_ok := false;
														for(var integer vl_eventNr := 0; vl_eventNr < vl_nrOfEvents; vl_eventNr := vl_eventNr + 1)
														{
															var XSD.String vl_event := 																		v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list[vl_eventNr].name;
													
															if(vl_event == vl_receivedMessage.elem_list[0].harness_event.name)
															{
																vl_event_is_ok := true;
															}
														}
											
														if(vl_event_is_ok == false) { setverdict(fail)}
														repeat;
													}
												}
											}
			
											[]InComm_PCO.receive(CompositeClientIq:?)
											{
												setverdict(fail);  
												Twait.stop;
											}
										}
									}
								
								//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ end actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
					
									
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 														tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
									vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
								
								}
							
								vl_nrOfActivations := vl_nrOfActivations + 1;
							//---------------------------------------------------------------------------------------------------------------------------------------------------------
							}
						}
					}
				}
				vl_nrOfActivations := 0;
			}

			vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
				vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
				for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
				{
					vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
					f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
				}
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS003_tool_resource() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
		
		f_TS002_query_harness();
			
		//number of ntaf.tools child nodes
		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
			//number of harnesses for a given node
			var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
				if(vl_harness == "http://ntaforum.org/2013/harness/resource/owner")
				{
					var SessionMode vl_supportedMode := invisible_and_automated;
				
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr);
					
					var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
				
					if(vl_activationSuccessful)
					{
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
					
						vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
			
						var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
						if(vl_sessionOpened)
						{
							f_StoreSession(vl_resultClientIq, vl_nrOfActivations, vl_nodeNr, 0);
						
							var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[0];
						
							f_RequestorSendReceiveClientIq(valueof(ts_Iq_perform_action_get_resources(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_nodeNr)), 																	ts_Iq_get_resources_response(vl_sessionId, pass_, vl_nodeNr), vl_resultClientIq);
							f_StoreResources(vl_resultClientIq, vl_nodeNr);
						
							f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 														tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
						}
						vl_nrOfActivations := vl_nrOfActivations + 1;
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
					}
				}
			}
			vl_nrOfActivations := 0;
		}

		vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function f_TS003_get_attributes_connectors() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
		
		f_TS002_query_harness();
			
		//number of ntaf.tools child nodes
		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
			//number of harnesses for a given node
			var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
				var boolean vl_inventory := false;
				if(vl_harness == "http://ntaforum.org/2013/harness/resource/inventory")
				{
			 		var integer vl_nrOfSubharnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].subharnessList);
					for(var integer vl_subharnessNr := 0; vl_subharnessNr < vl_nrOfSubharnesses; vl_subharnessNr := vl_subharnessNr + 1)
					{
						if(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].subharnessList[vl_subharnessNr] == "http://ntaforum.org/2013/harness/resource/owner")
						{
							vl_inventory := true;
						}
					} 
 				}
				
				if(vl_inventory)
				{
					var SessionMode vl_supportedMode := invisible_and_automated;
			
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr);
				
					var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
				
					if(vl_activationSuccessful)
					{	
					//--------------------------------------------------------------------------------------------------------------------------------------------------------- 						
						vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
			
						var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
						if(vl_sessionOpened)
						{
							f_StoreSession(vl_resultClientIq, vl_nrOfActivations, vl_nodeNr, 0);
						
							var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[0];
						
							f_RequestorSendReceiveClientIq(valueof(ts_Iq_perform_action_get_resources(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_nodeNr)), 																			ts_Iq_get_resources_response(vl_sessionId, pass_, vl_nodeNr), vl_resultClientIq);
							//Saving list of resources
							f_StoreResources(vl_resultClientIq, vl_nodeNr);
						
							//For every resource for a given node
							var integer vl_nrOfResources := sizeof(v_ntafNodes[vl_nodeNr].listOfResources);
							for(var integer vl_resourceNr := 0; vl_resourceNr < vl_nrOfResources; vl_resourceNr := vl_resourceNr + 1)
							{
								var XSD.String vl_resource := v_ntafNodes[vl_nodeNr].listOfResources[vl_resourceNr].resourceName;
															
								if(tsp_userAction)
								{
									Comm_PCO.send(ts_Iq_perform_action_request_user_input(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_resource, vl_nodeNr, vl_resourceNr));
			                               	
			                               	Twait.start(tsp_user_action_timer);
			                                    alt
									{
										[]Twait.timeout; { setverdict(fail);}
										[]InComm_PCO.receive(ts_Iq_user_input_response(vl_sessionId, pass_, vl_nodeNr, vl_resourceNr))
										{
											setverdict(pass);
											Twait.stop;
										}		
			                                    }
								}
								
								//asking for attributes
								var boolean vl_attributes := f_RequestorSendReceiveClientIq(valueof(ts_Iq_perform_action_get_attributes(vl_sessionId, v_ntafNodes[vl_nodeNr], 										vl_resource, vl_nodeNr, vl_resourceNr)), ts_Iq_get_attributes_response(vl_sessionId, pass_, vl_nodeNr, vl_resourceNr), vl_resultClientIq);
								
								if(vl_attributes)
								{
									f_StoreAttributes(vl_resultClientIq, vl_nodeNr, vl_resourceNr);
								}
							
								//asking for connectors
								var boolean vl_connectors := f_RequestorSendReceiveClientIq(valueof(ts_Iq_perform_action_get_connectors(vl_sessionId, v_ntafNodes[vl_nodeNr], 										vl_resource, vl_nodeNr, vl_resourceNr)), ts_Iq_get_connectors_response(vl_sessionId, pass_, vl_nodeNr, vl_resourceNr), vl_resultClientIq);
								
								if(vl_connectors)
								{
									f_StoreConnectors(vl_resultClientIq, vl_nodeNr, vl_resourceNr);
								}
							
							}
						
							f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 															 tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
						}
					
						vl_nrOfActivations := vl_nrOfActivations + 1;
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
					}
				}
			}
			vl_nrOfActivations := 0;
		}

		 vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
		
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS001_deactivate_wrong_actRef_separately() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var XSD.String vl_activationRef := "";
	var CompositeClientMessage vl_receivedMessage;
	var XSD.String vl_wrongActivationRef := "";
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
		
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
		
		//number of ntaf.tools child nodes
		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
			//number of harnesses for a given node
			var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
				//number of supportedModes for a given harness
				var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
				for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
				{
					var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
						
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr);
					
					var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
											
					if(vl_activationSuccessful)
					{	
					//--------------------------------------------------------------------------------------------------------------------------------------------------------- 						
						vl_wrongActivationRef := f_generate_random_string(6);
					
						vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
					
						f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_wrongActivationRef, vl_nodeId, "wrong")), 																	tr_CompIq_deactivate_result_fail(vl_activationId), vl_resultClientIq);
					
						f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_activationRef, vl_nodeId, vl_activationId)), 																	tr_CompIq_deactivate_result(vl_activationRef, vl_activationId), vl_resultClientIq);
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
					}
				}
			}
		}

		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	}

	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS001_activate_unsupportedMode() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var XSD.String vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
		
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
		
		//number of ntaf.tools child nodes
		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
					
			//number of harnesses for a given node
			var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				if(sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list) < 3)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
					var XSD.String vl_activationId := "unsupported_mode"
					
					if(v_ntafNodes[vl_nodeNr].proxy == true)
					{						
						f_RequestorSendReceiveClientIq(valueof(ts_Iq_activate_unsupportedMode_request(vl_nodeId, vl_toolId, vl_harness, vl_activationId)), 														tr_CompIq_request_Activate_request_fail(vl_toolId, vl_activationId), vl_resultClientIq);
						
						if(vl_resultClientIq.elem.activation_activate.result == pending)
						{		
							var XSD.String vl_requestId := vl_resultClientIq.id;
													
							Twait.start(20.0);
							alt
							{
								[]Twait.timeout; { setverdict(fail); }
					
								[]InComm_PCO.receive(tr_CompMessage_request_Activate_request_pass(vl_nodeId, vl_toolId, vl_requestId, vl_activationId)) -> value vl_receivedMessage
								{
									setverdict(pass);
									Twait.stop;
								}
							}
						}
					}
					else
					{
						f_RequestorSendReceiveClientIq(valueof(ts_Iq_activate_unsupportedMode_request(vl_nodeId, vl_toolId, vl_harness, vl_activationId)), 														tr_CompIq_request_Activate_request_fail(vl_toolId, vl_activationId), vl_resultClientIq);
					}
			
					if(vl_resultClientIq.elem.activation_activate.result == pass_ and vl_resultClientIq.error_ == omit)
					{
						f_StoreActivationRef(v_ntafNodes[vl_nodeNr], vl_resultClientIq, vl_nrOfActivations);
						vl_nrOfActivations := vl_nrOfActivations + 1;
					}
				}
				else
				{
					log("There is no unsupported mode as the harness supports all the modes.")
				}			
			}
			vl_nrOfActivations := 0;
		}

		vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				var XSD.String vl_activationId := "unsupported_mode"
			
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS001_activate_unsupportedHarness() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var XSD.String vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
		
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
		
		//number of ntaf.tools child nodes
		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
			var XSD.String vl_harness := f_generate_random_string(8);
				
			var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
				for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
				{
					log(v_ntafNodes[vl_nodeNr])
			
					var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
			
					var boolean vl_activationSuccessful := false;
			
					var XSD.String vl_activationId := "unsupported_harness_" & int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
				
					//activating a random generated harness
					f_RequestorSendReceiveClientIq(valueof(ts_Iq_activate_unsupportedHarness_request(v_ntafNodes[vl_nodeNr].nodeId, v_ntafNodes[vl_nodeNr].itemId, vl_activationId)), 																tr_CompIq_request_Activate_request_fail(v_ntafNodes[0].itemId, vl_activationId), vl_resultClientIq);
					
					if(vl_activationSuccessful)
					{
						f_StoreActivationRef(v_ntafNodes[vl_nodeNr], vl_resultClientIq, vl_nrOfActivations);
						vl_nrOfActivations := vl_nrOfActivations + 1;
					}
				}
			}
			vl_nrOfActivations := 0;				
		}

		vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS001_deactivate_wrong_actRef_altogether() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var XSD.String vl_activationRef := "";
	var CompositeClientMessage vl_receivedMessage;
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
		
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
		
		//number of ntaf.tools child nodes
		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
			//number of harnesses for a given node
			var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
				//number of supportedModes for a given harness
				var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
				for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
				{
					var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
			
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
					
					var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
				
					if(vl_activationSuccessful)
					{	
					//--------------------------------------------------------------------------------------------------------------------------------------------------------- 
						vl_nrOfActivations := vl_nrOfActivations + 1;
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
					}
				}
			}
			vl_nrOfActivations := 0;
		}

		vl_activationRef := "blabla";
		vl_nodeId := v_ntafNodes[0].nodeId;
		f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_activationRef, vl_nodeId, "wrong")), tr_CompIq_deactivate_result_fail("wrong"), vl_resultClientIq);


		vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}



//************************************************************************* 
function f_TS001_activate_already_activated() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var XSD.String vl_activationRef := "";
	var CompositeClientMessage vl_receivedMessage;
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
		
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
		
		//number of ntaf.tools child nodes
		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
			//number of harnesses for a given node
			var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
				//number of supportedModes for a given harness
				var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
				for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
				{										
					var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
					
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
					
					var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);	
					if(vl_activationSuccessful)
					{	
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
						vl_nrOfActivations := vl_nrOfActivations + 1;
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
					}
				}
			}
			vl_nrOfActivations := 0;
		}


		//number of ntaf.tools child nodes
		vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			
			//number of harnesses for a given node
			var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
				//number of supportedModes for a given harness
				var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
				for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
				{										
					var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
					
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
					
				//	var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
					var boolean vl_activationSuccessful := f_RequestorSendReceiveClientIq(valueof(ts_Iq_activate_always_on_tool_request(vl_nodeId, vl_toolId, vl_harness, 										vl_supportedMode, vl_activationId)), tr_CompIq_request_Activate_request_fail(vl_toolId, vl_activationId), vl_resultClientIq);
					if(vl_activationSuccessful)
					{	
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
						vl_nrOfActivations := vl_nrOfActivations + 1;
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
					}
				}
			}
		}


		vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}

//************************************************************************* 
function f_TS001_deactivate_already_deactivated() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var XSD.String vl_activationRef := "";
	var CompositeClientMessage vl_receivedMessage;
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
		
	if(f_TS001_preamble())
	{
		log("######################################## end of preamble ########################################")
		
		//number of ntaf.tools child nodes
		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			if(v_ntafNodes[vl_nodeNr].proxy == true)
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
			}
			else
			{
				vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			}
	
			vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
			//number of harnesses for a given node
			var integer nr_of_harnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
			for(var integer vl_harnessNr := 0; vl_harnessNr < nr_of_harnesses; vl_harnessNr := vl_harnessNr + 1)
			{
				var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
				//number of supportedModes for a given harness
				var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
				for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
				{										
					var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
					
					var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
					
					var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
						
					if(vl_activationSuccessful)
					{	
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
						vl_nrOfActivations := vl_nrOfActivations + 1;
					//---------------------------------------------------------------------------------------------------------------------------------------------------------
					}
				}
			}
			vl_nrOfActivations := 0;
		}

		vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_RequestorSendReceiveClientIq(valueof(ts_Iq_deactivate_always_on_tool_request(vl_activationRef, vl_nodeId, vl_activationId)), 														tr_CompIq_deactivate_result_fail(vl_activationId), vl_resultClientIq);
				//f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function f_TS002_open_session_without_activation() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var universal charstring vl_activationRef := "";
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
					
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
						vl_activationRef := f_generate_random_string(8);
				
						var XSD.String vl_activationId := "without_activation";								
						var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_fail(vl_activationId), vl_resultClientIq);
				
						if(vl_resultClientIq.elem.harness_response.result == pass_)
						{
							var XSD.Name vl_sessionId := vl_resultClientIq.elem.harness_response.session;
							f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), tr_Iq_close_session_result(vl_sessionId, 																										vl_activationId), vl_resultClientIq);
						}
					}
				}
			}
		}
	}
	
	log("######################################## start of postamble ########################################")
	
	f_TS001_postamble();
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}

//************************************************************************* 
function f_TS002_open_session_not_activated_mode() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var universal charstring vl_activationRef := "";
	var CompositeClientMessage vl_receivedMessage;
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
				
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list);
					if(vl_nrOfSupportedModes > 1)
					{
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[0];
		
						var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr);	
						
						var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
						if(vl_activationSuccessful)
						{	
						//--------------------------------------------------------------------------------------------------------------------------------------------------------- 							
							vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
			
							//Opening the session for the second mode supported by the node after activating it for the first supported mode.
							vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[1];
								
							f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 															vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_fail(vl_activationId), vl_resultClientIq);
							if(vl_resultClientIq.elem.harness_response.result == pass_)
							{
								var XSD.Name vl_sessionId := vl_resultClientIq.elem.harness_response.session;
								f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 																	tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
							}
							vl_nrOfActivations := vl_nrOfActivations + 1;
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function f_TS002_open_session_unsupported_mode() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var CompositeClientMessage vl_receivedMessage;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					if(vl_nrOfSupportedModes < 3)
					{
						for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
						{
							var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
			
							var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
			
							var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);			
				
							if(vl_activationSuccessful)
							{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 								
								vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
						
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 													vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
							
								var XSD.Name vl_sessionId := vl_resultClientIq.elem.harness_response.session;

								if(vl_sessionOpened)
								{
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 																 tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
								}
					
								var SessionMode vl_notSupportedMode := f_NotSupported(v_ntafNodes[vl_nodeNr], vl_harnessNr);
								f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, vl_notSupportedMode, "not_supported")), 																					tr_Iq_open_session_result_fail("not_supported"), vl_resultClientIq);
								if(vl_resultClientIq.elem.harness_response.result == pass_)
								{
									vl_sessionId := vl_resultClientIq.elem.harness_response.session;
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, "not_supported")), 																tr_Iq_close_session_result(vl_sessionId, "not_supported"), vl_resultClientIq);
								}
						
								vl_nrOfActivations := vl_nrOfActivations + 1;
							//---------------------------------------------------------------------------------------------------------------------------------------------------------
							}
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);

}


//************************************************************************* 
function f_TS002_close_closed_session() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var integer vl_nrOfActivations := 0;
	var universal charstring vl_activationRef := "";
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
						
						var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
						
						var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);	
						
						if(vl_activationSuccessful)
						{	
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
							vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
					
							var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 																vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
							var XSD.Name vl_sessionId := vl_resultClientIq.elem.harness_response.session;

							if(vl_sessionOpened)
							{
								f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 																		tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
							
								f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 																		tr_Iq_close_session_result_fail(vl_sessionId, vl_activationId), vl_resultClientIq);
							}
						
							vl_nrOfActivations := vl_nrOfActivations + 1;
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	}

	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}

//************************************************************************* 
function f_TS002_close_nonexisting_session() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var universal charstring vl_activationRef := "";
	var CompositeClientMessage vl_receivedMessage;
	var integer vl_nrOfActivations := 0;
	var XSD.String vl_randomSessionId := "";
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour());
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
			
						var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
			
						var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);	
							
						if(vl_activationSuccessful)
						{	
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
							vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
																	
							var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 																vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
							var XSD.Name vl_sessionId := vl_resultClientIq.elem.harness_response.session;

							if(vl_sessionOpened)
							{
								vl_randomSessionId := f_generate_random_string(8);
								log(vl_randomSessionId)
								f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_randomSessionId, vl_activationId)), 																		tr_Iq_close_session_result_fail(vl_randomSessionId, vl_activationId), vl_resultClientIq);
						
								f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 																	tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
							}
						
							vl_nrOfActivations := vl_nrOfActivations + 1;
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();
	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}

//************************************************************************* 
function  f_TS002_close_closed_session_altogether() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
					
						var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
			
						var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
			
						
						if(vl_activationSuccessful)
						{	
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
							vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
							
							vl_nrOfOpenedSessions := 0;
					
							var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
						
					
							if(vl_sessionOpened)
							{							
								f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
								vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
							}					
					
							vl_nrOfActivations := vl_nrOfActivations + 1;
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				var integer vl_nrOfSessionIds := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].sessionId_List);
			
				for(var integer vl_sessionNr := 0; vl_sessionNr < vl_nrOfSessionIds; vl_sessionNr := vl_sessionNr + 1)
				{
					log(vl_nrOfSessionIds)
					log(vl_sessionNr)
				
					var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].sessionId_List[vl_sessionNr];
					f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), tr_Iq_close_session_result(vl_sessionId, 																									vl_activationId),	vl_resultClientIq);
					f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), tr_Iq_close_session_result_fail(vl_sessionId, 																									vl_activationId), vl_resultClientIq);
									
					f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
				}
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS002_open_unsupportedMode_session_altogether() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{
						var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
			
						var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
					
						var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																			vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
										
						if(vl_activationSuccessful)
						{	
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
							
							vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
							
							vl_nrOfOpenedSessions := 0;
						
							f_StoreActivationRef(v_ntafNodes[vl_nodeNr], vl_resultClientIq, vl_nrOfActivations);
					
							vl_activationRef := vl_resultClientIq.elem.activation_activate.activationRef;
					
							var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 															vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
						
					
							if(vl_sessionOpened)
							{							
								f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
								vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
							}
					
							var SessionMode vl_notSupportedMode := f_NotSupported(v_ntafNodes[vl_nodeNr], vl_harnessNr);
							f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_notSupportedMode, "not_supported")), tr_Iq_open_session_result_fail("not_supported"), vl_resultClientIq);
							if(vl_resultClientIq.elem.harness_response.result == pass_)
							{
								f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
								vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
							}						
							vl_nrOfActivations := vl_nrOfActivations + 1;
						//---------------------------------------------------------------------------------------------------------------------------------------------------------
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				var integer vl_nrOfSessionIds := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].sessionId_List);
			
				for(var integer vl_sessionNr := 0; vl_sessionNr < vl_nrOfSessionIds; vl_sessionNr := vl_sessionNr + 1)
				{
					log(vl_nrOfSessionIds)
					log(vl_sessionNr)
				
					var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].sessionId_List[vl_sessionNr];
					f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), tr_Iq_close_session_result(vl_sessionId, 																									vl_activationId),	vl_resultClientIq);
				}
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);

}


//************************************************************************* 
function  f_TS002_perform_nonexisting_action() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
			
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list);
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{					
						//if one of the node's harnesses support invisible and automated mode
						if(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr] == invisible_and_automated)
						{
							var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[0];
							
							var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
			
							var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																					vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
					
							if(vl_activationSuccessful)
							{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 						
								vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
								
								vl_nrOfOpenedSessions := 0;
			
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 																vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
								if(vl_sessionOpened)
								{
									f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
				
									var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions];
					
								//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
						
									var XSD.String vl_actionId := vl_activationId;
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_perform_action_nonexisting(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_harnessNr, vl_actionId)), 											ts_Iq_perform_action_response(vl_sessionId, fail_, vl_actionId), vl_resultClientIq);
							
						
								//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ end actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
			
							
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 														tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
									vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
								}
								vl_nrOfActivations := vl_nrOfActivations + 1;
						
							//---------------------------------------------------------------------------------------------------------------------------------------------------------
							}
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				var integer vl_nrOfSessionIds := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].sessionId_List);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//************************************************************************* 
function  f_TS002_cancel_cancelled_action() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var CompositeClientMessage vl_resultClientMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
			
			f_TS002_query_harness();
			
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list)
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{					
						//if one of the node's harnesses support invisible and automated mode
						if(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr] == invisible_and_automated)
						{
							var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
							
							var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
						
							var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																					vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
							
							if(vl_activationSuccessful)
							{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 						
								vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
								
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
								if(vl_sessionOpened)
								{
									vl_nrOfOpenedSessions := 0;
						
									f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
				
									vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
									var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions];
					
							
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
					
									var integer vl_nrOfActions := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list);
									for(var integer vl_actionNr := 0; vl_actionNr < vl_nrOfActions; vl_actionNr := vl_actionNr + 1)
									{
										var XSD.String vl_actionId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr) & int2str(vl_actionNr);
										Comm_PCO.send(ts_Iq_perform_action(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_harnessNr, vl_actionNr, vl_actionId));    
							
										Twait.start(20.0);
										alt
										{
											[]Twait.timeout; {setverdict(pass);}
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pass_, vl_actionId))
											{
												Twait.stop;
											}
								
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pending, vl_actionId))
											{
												f_RequestorSendReceiveClientMessage(valueof(tr_CompMessage_cancel_requestor_request(v_ntafNodes[vl_nodeNr], 														vl_sessionId, vl_actionId)), tr_CompMessage_cancel_response(v_ntafNodes[vl_nodeNr], 															vl_sessionId, vl_actionId), vl_resultClientMessage);
									
												if(vl_resultClientMessage.elem_list[0].harness_response.result == abort)
												{
													f_RequestorSendReceiveClientMessage(valueof(tr_CompMessage_cancel_requestor_request(v_ntafNodes[vl_nodeNr], 														vl_sessionId, vl_actionId)), tr_CompMessage_cancel_response_fail(v_ntafNodes[vl_nodeNr], 															vl_sessionId, vl_actionId), vl_resultClientMessage);
												}
												Twait.stop;
									
											}
		
											[]InComm_PCO.receive(CompositeClientIq:?)
											{
												setverdict(fail);  
												Twait.stop;
											}
										}
									}
								
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ end actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
					
									
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 														tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
									vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
								}
					
								vl_nrOfActivations := vl_nrOfActivations + 1;
						
							//---------------------------------------------------------------------------------------------------------------------------------------------------------
							}
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}

//************************************************************************* 
function  f_TS002_cancel_finished_action() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var CompositeClientMessage vl_resultClientMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			f_TS002_query_harness();
		
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list);
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{					
						//if one of the node's harnesses support invisible and automated mode
						if(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr] == invisible_and_automated)
						{
							var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
			
							var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
							
							var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																					vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
							
							if(vl_activationSuccessful)
							{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 							
								vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
								
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 														vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
								if(vl_sessionOpened)
								{
									vl_nrOfOpenedSessions := 0;
						
									f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
						
									var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions];
				
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 

			
									var integer vl_nrOfActions := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list);
									for(var integer vl_actionNr := 0; vl_actionNr < vl_nrOfActions; vl_actionNr := vl_actionNr + 1)
									{
										var XSD.String vl_actionId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr) & int2str(vl_actionNr);
										Comm_PCO.send(ts_Iq_perform_action(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_harnessNr, vl_actionNr, vl_actionId));    
						
										Twait3.start(3.0);
										alt
										{
											[]Twait.timeout; {setverdict(pass);}
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pass_, vl_actionId))
											{
												Comm_PCO.send(tr_CompMessage_cancel_requestor_request(v_ntafNodes[vl_nodeNr], vl_sessionId, vl_actionId))
								
												Twait4.start(3.0)
												alt
												{
													[]Twait4.timeout { setverdict(pass) }
													[]InComm_PCO.receive(tr_CompMessage_cancel_response_fail(v_ntafNodes[vl_nodeNr], vl_actionId, vl_actionId))
													{
														setverdict(pass);
														Twait4.stop;
													}
													[]InComm_PCO.receive(tr_CompMessage_cancel_response(v_ntafNodes[vl_nodeNr], vl_sessionId, vl_actionId))
													{
														setverdict(fail);
														Twait4.stop;
													}
												}
												 
												Twait3.stop;
											}
							
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pending, vl_actionId))
											{
												Twait2.start(10.0)
												alt
												{
													[]InComm_PCO.receive(tr_Message_perform_action_response_pass(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_harnessNr, 																												vl_actionNr, vl_actionId))
													{
														setverdict(pass);
														Twait2.stop;
													}
									
													[]InComm_PCO.receive(tr_progress_update(v_ntafNodes[vl_nodeNr], vl_actionId, vl_sessionId))
													{
														repeat;
													}
									
													[]InComm_PCO.receive(ts_Message_perform_action_response_event(vl_sessionId, v_ntafNodes[vl_nodeNr], 																				vl_harnessNr, vl_actionNr)) -> value vl_receivedMessage
													{
														var integer vl_nrOfEvents := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list);
														var boolean vl_event_is_ok := false;
														for(var integer vl_eventNr := 0; vl_eventNr < vl_nrOfEvents; vl_eventNr := vl_eventNr + 1)
														{
															if(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list[vl_eventNr].name ==  																							vl_receivedMessage.elem_list[0].harness_event.name)
															{
																vl_event_is_ok := true;
															}
														}
														if(vl_event_is_ok == false) { setverdict(fail) }
														repeat;
													}
												}
												Twait3.stop;
											}
	
											[]InComm_PCO.receive(CompositeClientIq:?)
											{
												setverdict(fail);  
												Twait3.stop;
											}
										}
									}
					
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ end actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
		
						
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 														tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
									vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
					
								}
								vl_nrOfActivations := vl_nrOfActivations + 1;
						
							//---------------------------------------------------------------------------------------------------------------------------------------------------------
							}
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
								
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}

//************************************************************************* 
function  f_TS002_cancel_notStarted_action() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var CompositeClientMessage vl_resultClientMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
			
			f_TS002_query_harness();
			
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list);
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{					
						//if one of the node's harnesses support invisible and automated mode
						if(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr] == invisible_and_automated)
						{
							var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
			
							var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
			
							var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																					vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);
											
							if(vl_activationSuccessful)
							{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 						
								vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
			
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 															vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
								if(vl_sessionOpened)
								{
									f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
				
									var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions];
					
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
	
									var XSD.String vl_actionId := "not_started"
									
									var integer vl_nrOfActions := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list);
									for(var integer vl_actionNr := 0; vl_actionNr < vl_nrOfActions; vl_actionNr := vl_actionNr + 1)
									{
										Comm_PCO.send(tr_CompMessage_cancel_requestor_request(v_ntafNodes[vl_nodeNr], vl_sessionId, vl_actionId))
									
										Twait4.start(3.0)
										log("Waiting for cancel response " & int2str(vl_actionNr) & "/" & int2str(vl_nrOfActions))
										alt
										{
											[]Twait4.timeout { setverdict(pass) }
											[]InComm_PCO.receive(tr_CompMessage_cancel_response_fail(v_ntafNodes[vl_nodeNr], vl_sessionId, vl_actionId))
											{
												setverdict(pass);
												Twait4.stop;
											}
											[]InComm_PCO.receive(tr_CompMessage_cancel_response(v_ntafNodes[vl_nodeNr], vl_sessionId, vl_actionId))
											{
												setverdict(fail);
												Twait4.stop;
											}
											[]InComm_PCO.receive(CompositeClientIq : ?)
											{
												setverdict(fail);
												Twait4.stop;
											}
										}
									}
						
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ end actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
			
							
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 														tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
									vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
								}
					
								vl_nrOfActivations := vl_nrOfActivations + 1;
							//---------------------------------------------------------------------------------------------------------------------------------------------------------
							}
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}

//************************************************************************* 
function  f_TS002_cancel_nonExisting_action() runs on Requestor_CT
//*************************************************************************
{
	var CompositeClientIq vl_resultClientIq;
	var CompositeClientMessage vl_receivedMessage;
	var CompositeClientMessage vl_resultClientMessage;
	var universal charstring vl_activationRef := "";
	var integer vl_nrOfActivations := 0;
	var integer vl_nrOfOpenedSessions := 0;
	var XSD.String vl_nodeId := "";
	var XSD.String vl_toolId := "";
	
	v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
	
	if(f_TS001_preamble())
	{	
		if(f_TS002_preamble())
		{
			log("######################################## end of preamble ########################################")
		
			f_TS002_query_harness();
			
			//number of ntaf.tools child nodes
			var integer vl_nrOfNodes := sizeof(v_ntafNodes);
			for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
			{
				if(v_ntafNodes[vl_nodeNr].proxy == true)
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].proxy_jid;
				}
				else
				{
					vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
				}
	
				vl_toolId := v_ntafNodes[vl_nodeNr].itemId;
			
				//number of harnesses for a given node
				var integer vl_nrOfHarnesses := sizeof(v_ntafNodes[vl_nodeNr].harnesses);
				for(var integer vl_harnessNr := 0; vl_harnessNr < vl_nrOfHarnesses; vl_harnessNr := vl_harnessNr + 1)
				{
					var XSD.String vl_harness := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.name;
			
					//number of supportedModes for a given harness
					var integer vl_nrOfSupportedModes := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list);
					for(var integer vl_modeNr := 0; vl_modeNr < vl_nrOfSupportedModes; vl_modeNr := vl_modeNr + 1)
					{					
						//if one of the node's harnesses support invisible and automated mode
						if(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr] == invisible_and_automated)
						{
							var SessionMode vl_supportedMode := v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].harness.supportedMode_list[vl_modeNr];
			
							var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr);
			
							var boolean vl_activationSuccessful := f_ActivateTool(v_ntafNodes[vl_nodeNr], vl_nodeId, vl_toolId, vl_harness, vl_supportedMode, vl_activationId, 																					vl_resultClientIq, vl_receivedMessage, vl_nrOfActivations);			
				
							if(vl_activationSuccessful)
							{	
							//--------------------------------------------------------------------------------------------------------------------------------------------------------- 							
								vl_nrOfOpenedSessions := 0;
							
								vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].activate_.activationRef;
			
								var boolean vl_sessionOpened := f_RequestorSendReceiveClientIq(valueof(ts_Iq_open_session_requestor(vl_activationRef, vl_nodeId, vl_harness, 																vl_supportedMode, vl_activationId)), tr_Iq_open_session_result_pass(vl_activationId), vl_resultClientIq);
								if(vl_sessionOpened)
								{
									f_StoreSession(vl_resultClientIq, vl_nodeNr, vl_nrOfActivations, vl_nrOfOpenedSessions);
				
									var XSD.Name vl_sessionId := v_ntafNodes[vl_nodeNr].listOfActivations[vl_nrOfActivations].sessionId_List[vl_nrOfOpenedSessions];
					
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] 
	
				
									var integer vl_nrOfActions := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list);
									for(var integer vl_actionNr := 0; vl_actionNr < vl_nrOfActions; vl_actionNr := vl_actionNr + 1)
									{
										var XSD.String vl_actionId := int2str(vl_nodeNr) & int2str(vl_harnessNr) & int2str(vl_modeNr) & int2str(vl_actionNr);
										Comm_PCO.send(ts_Iq_perform_action(vl_sessionId, v_ntafNodes[vl_nodeNr], vl_harnessNr, vl_actionNr, vl_actionId));    
										Twait.start(20.0);

										alt
										{
											[]Twait.timeout; { setverdict(fail);}
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pass_, vl_actionId))
											{
												setverdict(pass);
												Twait.stop;
											}
											[]InComm_PCO.receive(ts_Iq_perform_action_response(vl_sessionId, pending, vl_actionId))
											{
												Twait2.start(10.0)
												alt
												{
													[]InComm_PCO.receive(tr_Message_perform_action_response_pass(vl_sessionId, v_ntafNodes[vl_nodeNr], 																		vl_harnessNr, vl_actionNr, vl_actionId))
													{
														setverdict(pass);
														Twait2.stop;
													}
										
													[]InComm_PCO.receive(tr_progress_update(v_ntafNodes[vl_nodeNr], vl_actionId, vl_sessionId))
													{
														repeat;
													}
										
													[]InComm_PCO.receive(ts_Message_perform_action_response_event(vl_sessionId, v_ntafNodes[vl_nodeNr], 																		vl_harnessNr, vl_actionNr)) -> value vl_receivedMessage
													{
														var integer vl_nrOfEvents := sizeof(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list);
														var boolean vl_event_is_ok := false;
														for(var integer vl_eventNr := 0; vl_eventNr < vl_nrOfEvents; vl_eventNr := vl_eventNr + 1)
														{
															if(v_ntafNodes[vl_nodeNr].harnesses[vl_harnessNr].action_list.actionDecl_list[vl_eventNr].name == 																									vl_receivedMessage.elem_list[0].harness_event.name)
															{
																vl_event_is_ok := true;
															}
														}
											
														if(vl_event_is_ok == false) { setverdict(fail)}
														repeat;
													}
												}
											}
	
											[]InComm_PCO.receive(CompositeClientIq:?)
											{
												setverdict(fail);  
												Twait.stop;
											}
										}
							
										//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ cancel non-existing action ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
										vl_sessionId := f_generate_random_string(6); 
										Comm_PCO.send(tr_CompMessage_cancel_requestor_request(v_ntafNodes[vl_nodeNr], vl_sessionId, vl_actionId))
									
										Twait4.start(3.0)
										alt
										{
											[]Twait4.timeout { setverdict(pass) }
											[]InComm_PCO.receive(tr_CompMessage_cancel_response_fail(v_ntafNodes[vl_nodeNr], vl_sessionId, vl_actionId))
											{
												setverdict(pass);
												Twait4.stop;
											}
											[]InComm_PCO.receive(tr_CompMessage_cancel_response(v_ntafNodes[vl_nodeNr], vl_sessionId, vl_actionId))
											{
												setverdict(fail);
												Twait4.stop;
											}
											[]InComm_PCO.receive(CompositeClientIq : ?)
											{
												setverdict(fail);
												Twait4.stop;
											}
										}
										//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[end cancel non-existing action]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
									}
						
									//[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[ end actions ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
								
							
									f_RequestorSendReceiveClientIq(valueof(ts_Iq_close_session_requestor(vl_nodeId, vl_sessionId, vl_activationId)), 														tr_Iq_close_session_result(vl_sessionId, vl_activationId), vl_resultClientIq);
									vl_nrOfOpenedSessions := vl_nrOfOpenedSessions + 1;
								}
					
								vl_nrOfActivations := vl_nrOfActivations + 1;
							//---------------------------------------------------------------------------------------------------------------------------------------------------------
							}
						}
					}
				}
				vl_nrOfActivations := 0;
			}
		}

		var integer vl_nrOfNodes := sizeof(v_ntafNodes);
		for(var integer vl_nodeNr := 0; vl_nodeNr < vl_nrOfNodes; vl_nodeNr := vl_nodeNr + 1)
		{
			vl_nodeId := v_ntafNodes[vl_nodeNr].nodeId;
			
			vl_nrOfActivations := sizeof(v_ntafNodes[vl_nodeNr].listOfActivations);
			for(var integer vl_activationNr := 0; vl_activationNr < vl_nrOfActivations; vl_activationNr := vl_activationNr + 1)
			{
				vl_activationRef := v_ntafNodes[vl_nodeNr].listOfActivations[vl_activationNr].activate_.activationRef;
				var XSD.String vl_activationId := int2str(vl_nodeNr) & int2str(vl_activationNr);
				
				f_DeactivateTool(v_ntafNodes[vl_nodeNr], vl_activationId, vl_activationRef, vl_resultClientIq);
			}
		}
		
		log("######################################## start of postamble ########################################")
		
		f_TS001_postamble();

	}
	
	Ctl_PCO.send("halt");
	
	deactivate(v_reqDefault);
}


//*************************************************************************
function  f_Preamble_postamble() runs on Requestor_CT
//*************************************************************************
{

        v_reqDefault:=activate(as_defaultRequestorBehaviour()); 
  	log(">>>---->>>######################################## start of f_Preamble_postamble()   ########################################")

	if(f_TS001_preamble())
	{		 
		 f_TS001_postamble();
	}

        Ctl_PCO.send("halt");
  	deactivate(v_reqDefault);
}



//************************************************************************* 
//Testcase TP_NTAF_TS_001_PREPOST_RBV_001
//Verify that the node ntaf.tools exists, if not exit, else create leaf node, read
//children of the ntaf node and read harnesses for the node under test.
//TS-001
//*************************************************************************
//************************************************************************* 
//
//	>>>> Preamble: <<<<
//	R								S
//	------------disco#info (ntaf.tools)------------->
//	<------------------response----------------------	if receiving error, ntaf.tools does not exist, tc stops
//
//	-----------disco#items (ntaf.tools)------------->
//	<------------------response----------------------	returns children nodes, one for every tool (if not poroxy)
//
//	----------delete leaf node requestor------------>	only if it already exists(it is returned as a child node in the disco#items response)
//	<------------------response----------------------
//
//	----------create leaf node requestor------------>
//	<------------------response----------------------
//	
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all the nodes:
//									T	
//	---------------fetch tool registry-------------->
//	<------------------response----------------------	returns a list of harnesses, if max_items is omit, the node is a proxy
//	
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>> Postamble: <<<<
//									S
//	----------delete leaf node requestor------------>
//	<------------------response----------------------
//
//*************************************************************************
testcase tc_TS001_preamble_postamble() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_Preamble_postamble());


	Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}


//************************************************************************* 
//Testcase TP_NTAF_TS_001_ACT_RBV_001
//Activate/deactivate every tool and each supported mode separately.
//TS-001
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS001_act_deact_separately() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor, "titan0", "titan0", tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());

	v_Requestor_CT.start(f_TS001_act_deact_separately());
	
        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();	
}


//************************************************************************* 
//Testcase TP_NTAF_TS_001_ACT_RBV_005
//Activate every tool and each supported mode and then deactivate all.
//TS-001
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS001_act_deact_altogether() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS001_act_deact_altogether());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
	
}



//*************************************************************************************************************************************
//TS-002
//*************************************************************************************************************************************


//************************************************************************* 
//Testcase TP_NTAF_TS_002...
//Discovering harness support for each node, and harness details for every harness.
//Checking if all the harnesses the server reported are reported by the harness as well.
//TS-002
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all the nodes:
//									T
//	------------------disco#info ------------------->
//	<------------------response----------------------	feature list (should include all the harnesses)
//	
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all nodes and harnesses:
//
//	-----------------query harness------------------>
//	<------------------response----------------------	list of harness actions and other infos
//	
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_disco_info_query_harness() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_disco_info_query_harness());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
	
}


//************************************************************************* 
//Testcase TP_NTAF_TS_002...
//Activating a node and opening a session for all node and every harness and each supported mode separately.
//TS-002
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//			
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//	------open session(activation reference)-------->
//	<------------------response----------------------	if pass, returns session Id
//
//	----------close session(session Id)------------->
//	<------------------response----------------------
//
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_open_session_separately() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_open_session_separately());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
	
}


//************************************************************************* 
//Testcase TP_NTAF_TS_002...
//Activating a node and opening a session for all node and every harness and each supported mode altogether.
//TS-002
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//	------open session(activation reference)-------->
//	<------------------response----------------------	if pass, returns session Id
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all activated tools:
//
//		>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//		for all opened sessions:
//
//	----------close session(session Id)------------->
//	<------------------response----------------------
//
//		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//	
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_open_session_altogether() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_open_session_altogether());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
	
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002...
//Activating nodes that support visible_and_interactive mode and waiting for a user activity notification message.
//TS-002
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and visible_and_interactive:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//	------open session(activation reference)-------->
//	<------------------response----------------------	if pass, returns session Id
//
//	---------------------action--------------------->	"Please send user activity notification message" 
//	<----------------notify action-------------------
//
//	----------close session(session Id)------------->
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_user_activity_notification() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_user_activity_notification());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
	
}



//************************************************************************* 
//Testcase TP_NTAF_TS_002...
//Waiting for a no more sessions available presence message, if received, closing a session and waiting for a presence available message.
//If presence available is also received, closing all the sessions and deactivating nodes.
//!!Accepts all incoming presence messages, not only presence available.!!
//TS-002
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//	------open session(activation reference)-------->
//	<---------------response(pass)-------------------	if pass, returns session Id
//
//			 repeat open session				while not receiving no_more_sessions_available
//
//	<------------------presence----------------------	no_more_sessions_available
//	----------------close session------------------->	close the last session opened
//	<------------------response----------------------
//	<------------------presence----------------------	session_available
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//		
//		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//		for all opened sessions:
//
//	----------close session(session Id)------------->
//	<------------------response----------------------
//
//		>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_session_resource_availability() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_session_resource_availability());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
	
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002...
//Activating nodes that support visible_and_interactive mode and waiting for a notify close message.
//TS-002
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and visible_and_interactive:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//	------open session(activation reference)-------->
//	<------------------response----------------------	if pass, returns session Id
//
//	---------------------action--------------------->	"Please send notify_close message" 
//	<----------------notify close--------------------	
//									|or
//	----------close session(session Id)------------->	if no notify_close is received in a given time
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_notify_close() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_notify_close());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}


//************************************************************************* 
//Testcase TP_NTAF_TS_002...
//Performing all the actions for all node and every harness in visible_and_automated mode if supported.
//Result can be pass, fail or pending, if pending waiting for further messages(progress and event notification).
//If and event notification is received it has to be verified against the harness declaration.
//TS-002
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and visible_and_automated:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//	------open session(activation reference)-------->
//	<------------------response----------------------	if pass, returns session Id
//
//		>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//		for all the actions:
//
//	----------------perform action------------------>
//
//
//	<------------------pass/fail---------------------
//									|or
//	<-------------------pending----------------------
//	<---------------progress update------------------
//									|or
//	<--------------event notification----------------
//
//
//	<------------------pass/fail---------------------
//
//		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<							
//										
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_performing_actions_visible_and_automated() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_performing_actions_visible_and_automated());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}


//************************************************************************* 
//Testcase TP_NTAF_TS_002...
//Performing all the actions for all node and every harness in invisible_and_automated mode if supported.
//Result can be pass, fail or pending, if pending waiting for further messages(progress, event notification).
//If and event notification is received it has to be verified against the harness declaration.
//TS-002
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and invisible_and_automated:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//	------open session(activation reference)-------->
//	<------------------response----------------------	if pass, returns session Id
//
//		>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//		for all the actions:
//
//	----------------perform action------------------>
//
//
//	<------------------pass/fail---------------------
//									|or
//	<-------------------pending----------------------
//	<---------------progress update------------------
//									|or
//	<--------------event notification----------------
//
//
//	<------------------pass/fail---------------------
//
//		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<							
//										
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_performing_actions_invisible_and_automated() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_performing_actions_invisible_and_automated());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
	
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002...
//Performing all the actions for all nodes and every harnesses in invisible_and_automated mode if supported.
//Result can be pass, fail or pending, if pending waiting for further messages(presence, event notification).
//If and event notification is received it has to be verified against the harness declaration.
//TS-002
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and invisible_and_automated:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//	------open session(activation reference)-------->
//	<------------------response----------------------	if pass, returns session Id
//
//		>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//		for all the actions:
//
//	----------------perform action------------------>
//
//	<------------------pass/fail---------------------
//									|or
//	<-------------------pending----------------------
//	-----------------cancel action------------------>
//	<------------------response----------------------
//
//		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<							
//										
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_performing_actions_cancelling() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_performing_actions_cancelling());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
	
}

//*************************************************************************************************************************************
//TS-003-004
//*************************************************************************************************************************************

//************************************************************************* 
//Testcase TP_NTAF_TS_003_...
//Tool resource
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//	
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes if resources harness is supported:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//	------open session(activation reference)-------->
//	<------------------response----------------------	if pass, returns session Id
//
//	----------------perform action------------------>	get resources
//	<------------------response----------------------	pass
//											
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS003_tool_resource() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS003_tool_resource());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}



//************************************************************************* 
//Testcase TP_NTAF_TS_003_...
//Get tool resource attributes and connectors.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//	
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes if resources harness is supported:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//	
//	------open session(activation reference)-------->
//	<------------------response----------------------	if pass, returns session Id
//
//	----------------perform action------------------>	get resources
//	<------------------response----------------------	pass(saving resources)
//
//	----------------perform action------------------>	get attributes
//	<------------------response----------------------	pass
//									
//	----------------perform action------------------>	get connectors
//	<------------------response----------------------	pass
//											
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS003_get_attributes_connectors() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS003_get_attributes_connectors());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}


//*************************************************************************************************************************************
// Negative testcases
//*************************************************************************************************************************************

//*************************************************************************************************************************************
//TS-001
//*************************************************************************************************************************************

//************************************************************************* 
//Testcase TP_NTAF_TS_001_ACT_RBV_002
//Activating one of the harnesses and then deactivating a wrong activation
//reference.
//*************************************************************************
//*************************************************************************
//
//	R								S
//	-------------------Preamble----------------------
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass (activation reference received here)
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	(activation reference received here)
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS001_deactivate_wrong_actRef_separately() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS001_deactivate_wrong_actRef_separately());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}


//************************************************************************* 
//Testcase TP_NTAF_TS_001_ACT_RBV_003
//Activating a tool with an unsupported mode.
//First checking if all the modes are supported by the tool, if not, activating the tool
//with all the modes. If the result is not fail_ the testcase fails.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//									T
//	-----------------activate tool------------------>	activating tool with all three modes if not all three modes are supported by the tool
//	<------------------response----------------------	fail
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	fail

//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------	
//	
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS001_activate_unsupportedMode() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS001_activate_unsupportedMode());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//************************************************************************* 
//Testcase TP_NTAF_TS_001_ACT_RBV_004
//Activating a tool with an unsupported harness. First activating all the tools
//with all of the harnesses and then activating an unsupported harness.
//If the result is not fail_ the testcase fails.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all nodes and harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	fail
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	fail
//
//	-----------------activate tool------------------>	random generated harness name
//	<------------------response----------------------	fail
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS001_activate_unsupportedHarness() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS001_activate_unsupportedHarness());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}


//************************************************************************* 
//Testcase TP_NTAF_TS_001_ACT_RBV_006
//Activating all the harnesses in all the supported modes altogether and
//then sending a deactivate with a non-existing activationReference before
//deactivating harnesses.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//	
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all nodes, harnesses, modes:	
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	--deactivate tool(wrong activation reference)--->	proxy
//	<------------------response----------------------	fail
//									T
//	--deactivate tool(wrong activation reference)--->	
//	<------------------response----------------------	fail
//	
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS001_deactivate_wrong_actRef_altogether() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS001_deactivate_wrong_actRef_altogether());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}


//************************************************************************* 
//Testcase TP_NTAF_TS_001_ACT_RBV_007
//Activating all the harnesses in all the modes and activate them again.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all nodes and harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//	
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all nodes and harnesses and modes:
//
//	-----------------activate tool------------------>	
//	<------------------response----------------------	fail
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	fail
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//	
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS001_activate_already_activated() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS001_activate_already_activated());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}


//************************************************************************* 
//Testcase TP_NTAF_TS_001_ACT_RBV_007
//Activating all the harnesses in all the modes and deactivating them twice.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all nodes and harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//	
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//	
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------	fail
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------	fail
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS001_deactivate_already_deactivated() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS001_deactivate_already_deactivated());


        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//*************************************************************************************************************************************
//TS-002
//*************************************************************************************************************************************

//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Opening a session without activating anything.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	
//	------open session(activation reference)-------->	activation reference is f_genereate_random_string()
//	<------------------response----------------------	fail
//	
//	----------close session(session Id)------------->	if opensession didn't fail
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_open_session_without_activation() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_open_session_without_activation());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//If a node supports at least two modes, activating the harnesses for the first
//mode supported and opening a session for the second mode. 
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:			if at least two modes are supported
//									T
//	-----------------activate tool------------------>	first mode supported by the tool
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//	
//	------open session(activation reference)-------->	second mode supported by the tool
//	<------------------response----------------------	fail
//
//	----------close session(session Id)------------->	if opening a session didn't fail
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//*************************************************************************
testcase tc_TS002_open_session_not_activated_mode() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_open_session_not_activated_mode());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}


//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Activating all the tools and harnesses in all the supported modes if less than 3.
//Opening sessions separately, closing them, deactivating and then activating
//a supported mode again but opening an unsupported mode session.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>	
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//	
//	------open session(activation reference)-------->	
//	<------------------response----------------------	
//
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//	
//	------open session(activation reference)-------->	for a not supported mode
//	<------------------response----------------------	fail
//
//	----------close session(session Id)------------->	if opening a session didn't fail
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_open_session_unsupported_mode() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor, "titan0", "titan0", tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_open_session_unsupported_mode());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Activating, opening separately and closing everything twice.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//	
//	------open session(activation reference)-------->	
//	<------------------response----------------------	
//
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	----------close session(session Id)------------->	
//	<------------------response----------------------	fail
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_close_closed_session() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_close_closed_session());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Activating, opening, closing separately and closing a nonexisting session.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//	
//	------open session(activation reference)-------->	
//	<------------------response----------------------	
//
//	----------close session(session Id)------------->	session Id is f_generate_random_string()
//	<------------------response----------------------	fail
//
//	----------close session(session Id)------------->	
//	<------------------response----------------------	
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_close_nonexisting_session() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_close_nonexisting_session());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Activating, opening, closing separately and closing a nonexisting session.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass	
//	
//	------open session(activation reference)-------->	
//	<------------------response----------------------	
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//	
//		>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//		for all opened sessions:
//
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	----------close session(session Id)------------->	session Id is the same as the first one
//	<------------------response----------------------	fail
//
//		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_close_closed_session_altogether() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_close_closed_session_altogether());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}


 //************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Activating, opening a session, opening an other session with an unsupported mode
//for the same activation for every node and every harness and every mode.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>	
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//	
//	------open session(activation reference)-------->	
//	<------------------response----------------------	
//	
//	------open session(activation reference)-------->	for a not supported mode
//	<------------------response----------------------	fail
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//	
//		>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//		for all opened sessions:
//
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_open_unsupportedMode_session_altogether() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_open_unsupportedMode_session_altogether());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Activating, opening, closing separately and performing a non-existing action that
//is a random gerenated string.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>	
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//	
//	------open session(activation reference)-------->	
//	<------------------response----------------------	
//	
//	----------------perform action------------------>	non-existing action
//	<------------------response----------------------	fail
//
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_perform_nonexisting_action() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_perform_nonexisting_action());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Activating, opening, performing an action if invisible and automated mode is supported.
//When receiving pending, cancelling the action and cancelling again is succeeded.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>	
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//	
//	------open session(activation reference)-------->	
//	<------------------response----------------------	
//	
//	----------------perform action------------------>	
//	<------------------response----------------------	pass/fail
//									|or
//	<------------------response----------------------	pending
//	-----------------cancel action------------------>
//	<------------------response----------------------	abort
//
//	-----------------cancel action------------------>
//	<------------------response----------------------	fail
//
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_cancel_cancelled_action() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_cancel_cancelled_action());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Activating, opening, performing an action if invisible and automated mode is supported.
//When receiving pass, cancel action.
//Verdict is pass if fail or nothing is received.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>	
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//	
//	------open session(activation reference)-------->	
//	<------------------response----------------------	
//	
//	----------------perform action------------------>	
//	<------------------response----------------------	pass
//
//	-----------------cancel action------------------>
//	<------------------response----------------------	fail or no response at all
//
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_cancel_finished_action() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_cancel_finished_action());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Activating, opening if invisible and automated mode is supported.
//Cancelling an action not started.
//Verdict is pass if fail or nothing is received.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and modes:
//									T
//	-----------------activate tool------------------>	
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//	
//	------open session(activation reference)-------->	
//	<------------------response----------------------	
//	
//		>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//		for all the actions:
//
//	-----------------cancel action------------------>
//	<------------------response----------------------	fail or no response at all
//
//		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	for all activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//	
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_cancel_notStarted_action() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_cancel_notStarted_action());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}

//************************************************************************* 
//Testcase TP_NTAF_TS_002_...
//Activating, opening, performing an action if invisible and automated mode is supported.
//Cancelling a random generated non-existing action.
//Verdict is pass if fail or nothing is received.
//*************************************************************************
//************************************************************************* 
//
//	R								S
//	-------------------Preamble----------------------
//
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the nodes, harnesses and visible_and_automated:
//									T
//	-----------------activate tool------------------>
//	<------------------response----------------------	pass
//									|or
//	<------------------response----------------------	pending
//	<----------------pass messsage-------------------	pass
//	
//	------open session(activation reference)-------->
//	<------------------response----------------------	if pass, returns session Id
//
//		>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//		for all the actions:
//
//	----------------perform action------------------>
//
//
//	<------------------pass/fail---------------------
//									|or
//	<-------------------pending----------------------
//	<---------------progress update------------------
//									|or
//	<--------------event notification----------------
//
//	<------------------pass/fail---------------------
//
//	-----------------cancel action------------------>	cancel non-existing action
//	<------------------response----------------------	fail
//
//		<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<							
//										
//	----------close session(session Id)------------->	
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<	
//
//	>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>			
//	for all the activations:
//									P
//	-----deactivate tool(activation reference)------>	if proxy
//	<------------------response----------------------
//									T
//	-----deactivate tool(activation reference)------>
//	<------------------response----------------------
//
//	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
//									S
//	-------------------Postamble---------------------
//
//*************************************************************************
testcase tc_TS002_cancel_nonExisting_action() runs on MTC_CT
{
	ConfigurationBuild();

	v_RequestorMapping_CT.start(f_ScanClientPorts(tsp_AuthType_requestor,"titan0","titan0",tsp_localPortRequestor));
	
	alt { []Ctlrm_PCO.receive("ready")    {};   }

	v_TranslatorR_CT.start(f_ScanTranslatorPorts());
	
	v_Requestor_CT.start(f_TS002_cancel_nonExisting_action());

        Twait.start(180.0); 
	alt
	{
		[]Ctlr_PCO.receive("halt")    
		{
			Ctlrt_PCO.send("halt");
			Ctlrm_PCO.send("halt");
		};
		[]Twait.timeout {};		

	}//endalt

	all component.done;
	ConfigurationKill();
}





}//endmodule
